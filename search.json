[{"title":"在vue项目里实现百度地图坐标转换","url":"/2022/09/27/记录在vue项目里实现百度地图坐标转换的操作/","content":"\n# 在vue项目里实现百度地图坐标转换\n\n> 背景\n\n​\t\t背景是这样的，因项目需要，在网页中要放置一张百度地图，用来显示各种不同局站的地理分布，大概有几百个坐标需要同时显示。而甲方给的数据表中的坐标是大地坐标系（WGS84），而百度地图使用的则是自己的百度坐标系（bd09），因此直接显示会有偏移而不准确，所以要进行纠偏后才能正常显示。\n\n> 百度提供的接口\n\n百度坐标转换接口的服务文档：\nhttps://lbsyun.baidu.com/index.php?title=webapi/guide/changeposition\n\n接口：\nhttp://api.map.baidu.com/geoconv/v1/?coords=114.21892734521,29.575429778924&from=1&to=5&ak=你的密钥 //GET请求\n\n按照服务文档的说明，可以通过这个接口提交坐标转换的申请，即发送需要转换的坐标、源坐标类型、目标坐标类型，从而得到一个状态码和坐标转换后的结果，其格式如下：\n\n```js\n{\"status\":0,\"result\":[{\"x\":117.19322369775665,\"y\":39.12574664331678}]}\n```\n\n从这个返回值中可以取回坐标值应用到我们的地图组件中。\n\n> 原始数据\n\n在项目里我们通过`axios`从后台获取到数据表并放入**pointData**数组中\n\n```js\naxios({\n      method: \"get\",\n      url: \"...\",\n    }).then((res) => {\n      if (res.data.success) {\n        this.pointData = res.data.data;\n      };\n    })\n```\n\n**pointData**包含了多个数组对象，每个数组对应不同类型的局站，每个数组下又包含100个左右具体局站的数据信息。\n\n例如某一个局站的经度可以这样调用\n\n```js\npointData[0][0].lat //该局站的维度\n```\n\n> 面临问题\n\n**问题（一）：**跨域\n\n​\t\t在本地如果直接用`axios`调用百度接口会因为浏览器的跨域资源共享（CORS）机制而导致无法获取数据\n\n**问题（二）：**发送坐标\n\n​\t\t百度地图接口单次最多可以接收100个坐标，因此需要将原始数据里的坐标提出来并拼接成为一个字符串\n\n**问题（三）：**异步执行问题\n\n​\t\t每一次向接口发送请求都是一个异步操作，而我们数据的组装是有顺序的，需要进行同步操作才能够实现我们的功能\n\n> 解决方案\n\n**一：**使用JSONP解决跨域问题\n\n​\t\tJsonp（JSON with Padding）是 json 的一种\"使用模式\"，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。\n\n---\n\n1. 首先安装jsonp依赖\n\n   ```js\n   npm i vue-jsonp --save\n   ```\n\n2. 接着在main.js上导入并安装\n\n   ```js\n   import VueJsonp from 'vue-jsonp'\n   Vue.use(VueJsonp)\n   ```\n\n3. 接下来就可以通过调用`this.$jsonp(url)`来进行跨域访问链接了\n\n   ```js\n   this.$jsonp(url).then((res)=>{\n   \tif (!res.status) {\n       \t//...处理语句\n           }})\n   ```\n\n**二：**进行字符串拼接（坐标转换方法）\n\n​\t\t可以将数据中的坐标提取出来每100个拼接成为一个字符串并进行一次转换申请，如果对每一个坐标单独转换的话，会产生相当高的并发，容易超过百度接口的额度，并且会造成服务器的延迟，增加复杂度。\n\n---\n\n```js\nasync converted(){\n    //s为拼接后的字符串\n    var s = \"\";\n    var i = 0;\n    //points为装载所有转换后的点的坐标列表\n    var points = [];\n    //temp为临时存放坐标的集合\n    var temp = [];\n\t//字符串拼接并发送请求\n    for(var j = 0;j<this.pointData.length;j++){\n        // console.log(`循环第${j}次`)\n        for(let item of this.pointData[j]){\n            s += item.lng + \",\" + item.lat + \";\"\n            i++;\n            //到100个时开始发送请求并将返回值保存\n            if(i == 100){\n                //发送一次请求并等待返回\n                let res = await this.send(s);\n                //将这次返回结果装入temp数组\n                temp = temp.concat(res.result);\n                //清空坐标进行下一轮请求\n                s = \"\";\n                i = 0;\n            }\n        }\n        //将剩下的坐标发送请求\n        let res = await this.send(s);\n        //返回的坐标全部保存在temp数组中\n        temp = temp.concat(res.result);\n        //将这一组坐标装入points数组中\n        points.push(temp);\n        temp = [];\n        s = \"\"; \n    }\n    //对原始坐标进行转换\n    for(var j = 0; j < this.pointData.length; j++){\n        //console.log(`第${j}组转换`)\n        for (let [index,item] of this.pointData[j].entries()) {\n            item.lng = points[j][index].x;\n            item.lat = points[j][index].y;\n        }\n    }\n    return 0;\n}\n```\n\n**三：**使用**async**、**await**关键字和**promise**对象解决异步问题\n\n> > Event Loop\n\n​\t\tJavaScript语言一种单线程语言，所有任务都在一个线程上完成，单线程的运行方式为**“同步模式”（synchronous I/O）**或**“堵塞模式”（blocking I/O）**\n\n​\t\t于是就采用**Event Loop**机制，来解决单线程运行带来的一些问题。就是在程序中设置两个线程：一个负责程序本身的运行，称为**\"主线程\"**；另一个负责主线程与其他进程（主要是各种I/O操作）的通信，被称为**\"Event Loop线程\"（可以译为\"消息线程\"）**。\n\n​\t\t每当遇到I/O的时候，就**Event Loop**线程去做，而主线程继续往后运行。当I/O操作完成，**Event Loop**线程再把结果返回，完成调用其回调函数完成任务。\n\n​\t\t于是，主线程可以在相同时间运行更多的任务，这种运行方式称为**“异步模式”（asynchronous I/O）**或**“非堵塞模式”（non-blocking mode）**。\n\n---\n\n​\t\t正是由于**Event Loop**机制的存在，程序中的I/O操作都是异步模式。在前面的坐标转换方法中，我们的`pointData`数组中装了很多组坐标，每一组都是某一种类型局站的坐标，因此整个转换请求方法需要两个for循环才能全部转换完成。\n\n​\t\t当我们仅实现一组的坐标转换时，**Event Loop**机制并不会对结果产生影响，而进行下一组转换前，`temp`的值要`push`到`points`中之后并被清空，此时问题就来了。\n\n​\t\t我们知道，**Event Loop**线程会和主线程分离，**也就是说for循环并不管我们发送的I/O请求是否返回了结果，就继续往下执行**。有可能temp还是空的时候，我们的主线程的一轮循环就结束了，结果这一组坐标就没有被装进去，可能被装进下一组中甚至丢失，总之无法实现我们想要的结果。\n\n​\t\t也就是说，我们希望这个程序是**完全同步**的，每一个语句完全执行完毕再进行下一个语句，但是**Event Loop**导致他是异步的，所以便出现了错误。\n\n要想解决这个问题，我们就需要使用**async**、**await**关键字和**promise**对象了。\n\n---\n\n1. **async、await**关键字\n\n   **async**用于声明一个函数是异步的。而**await**从字面意思上是“等待”的意思，是`async await`的简写，用于等待异步完成。并且**await**只能在**async**函数内使用，**简单理解就是，async 声明的函数内的异步会按照同步执行顺序**。通常**async**、**await**都是跟随**Promise**一起使用的。\n\n   在希望其内运行顺序为同步的函数名前加上`async`关键字，在其中的异步I/O操作前加上`await`关键字\n\n   ```js\n   let res = await this.send(s);\n   ```\n\n   我们的`s`是一个坐标字符串，即待转换的一组坐标，`send()`函数是一个I/O请求，`res`为返回的转换后的坐标，加上`await`关键字之后，程序运行到这一句将等待`send()`函数返回，即res中得到返回值后再向下运行\n\n2. **promise**对象\n\n   **promise**,简单来说就是一个容器，里面保存着某个未来才会结束的时间(通常是一个异步操作的结果)\n\n   **promise**有三个状态：**pending**（执行中）、**success**（成功）、**rejected**（失败），当执行成功会返回`resolve()`中的值，失败则会返回`reject()`中的值\n\n   **await**后面要跟一个**promise**对象才能进行阻塞，若不是**promise**对象，则还是会直接执行下面的语句。\n\n   ```js\n   send(s){\n         return new Promise((resolve, reject)=>{\n           s = s.substring(0,s.length-1);\n           s = \"http://api.map.baidu.com/geoconv/v1/?coords=\" + s + \"&from=3&to=5&ak=DZSjokGwq1OaHmR4iEhN4O0TXb0ImGBS\";\n           this.$jsonp(\n             s\n           ).then((res)=>{\n             if (!res.status) {\n               resolve(res)\n           }\n           }).catch(err =>{\n             reject(err)\n           });\n         })\n       }\n   ```","categories":["tech"]},{"title":"记录一次配置项目到ubuntu服务器上的操作","url":"/2022/09/27/服务器配置/","content":"\n## 记录一次配置项目到服务器上的操作\n\n## ubuntu\n\n### 连接远程服务器\n\n打开命令符，输入`ssh 用户名@服务器ip地址`，之后输入密码即可进入\n\n### 前端vue项目打包\n\n1. `npm run build`：编译代码到./dist文件夹下\n\n2. 使用scp命令将dist文件夹传到服务器的前端文件夹下\n\n   `scp -r dist ubuntu@服务器ip地址:/home/ubuntu/font`\n\n### 后端Java项目打包\n\n1. 点击maven，点击Lifcycle下的package，将项目打包为一个jar包\n2. 使用scp命令将jar包传到服务器的后端文件夹下（scp命令不需要加 -r参数了，因为-r是传文件夹）\n\n### 配置服务器\n\n#### 安装jdk\n\n1. 在本机下载jdk-8u271-linux-x64.tar.gz\n2. 将jdk传到服务器上，使用命令`scp ./文件名 用户名@地址:/存放路径  ` \n3. 进入服务器cd到存放jdk的路径中，安装jdk：`tar -zxvf ./jdk-8u271-linux-x64.tar.gz`\n4. 安装后得到一个文件夹jdk1.8.0_271，可以使用命令移动到java1.8文件夹下：`mv ./jdk1.8.0_271 java1.8`\n5. `sudo vim /etc/profile`：使用vim编辑环境变量，将jdk配置到环境变量中\n6. 在vim中，按`i`键进入编辑模式，编辑完成后，按`esc`退出编辑模式，按住`shift`再按两次`z`退出vim编辑器\n7. 输入`source /etc/profile`执行该文件一下使配置生效\n8. 输入java、javac查看java环境是否安装成功\n\n#### 安装nginx\n\n1. `sudo apt-get install nginx`：安装nginx\n2. 在/etc/nginx/conf.d文件夹下创建自定义配置文件nginx.conf\n3. 编辑该配置文件\n4. \n\n```markdown\nserver{\nlisten 8001;\nserver_name localhost;\n#charset koi8-r;\n#access_log /var/log/nginx/host.access.1og main;\nlocation / {\n#root /usr/share/nginx/html;\nroot /home/ubuntu/font/dist;\nindex index.html index.htm;\n}\n```\n\n#### 前端配置\n\n前端项目在/home/ubuntu/font/dist里，通过nginx引用即可\n\n#### 配置后端\n\n1. `mkdir back`：创建名为back的前端文件夹\n2. 本机将jar包上传到back中\n3. 在服务器中`cd back`切换到back目录下，`ls`查看当前目录文件\n4. `touch start.sh`：创建启动脚本\n5. 编辑启动脚本内容输入\n   `nohup java -jar jieruwangjavasu-0.0.1-SNAPSHOT.jar &`\n6. `sh start.sh`：启动脚本，会输出一个`nohup.out`文件\n7. `cat nohup.out`：查看该文件内容了解后台是否启动\n8. `ps -ef |grep jieruwangjavasu-0.0.1-SNAPSHOT.jar`：查看该jar包的启动进程\n9. `kill+pid`：可以杀死某pid的进程\n10. `rm -rf+文件名`：可以删除某文件\n\n#### 启动nginx\n\n`systemctl start nginx`：启动nginx\n\n`systemctl status nginx`：查看nginx启动状态\n\n`sudo lsof -i:8001`：查看端口占用\n\n`sudo systemctl restart nginx`：重启nginx\n\n### 安装mysql\n\n#### mysql 5.7\n\n1. `sudo apt-get install mysql-server-5.7`：安装MYSQL5.7\n2. `sudo apt install libmysqlclient-dev`：安装依赖\n3. `sudo netstat -tap | grep mysql`：检查状态\n4. `sudo su`：进入root用户\n5. `mysql -u root -p`：进入mysql，初始密码为空\n6. `show databases`：查看数据库\n7. `use mysql`：进入mysql数据库\n8. `select host, user from user`：查看用户及其地址\n9. `update user set host='%' where user = 'root'`：设置root的host为%，即任何地址可连接\n10. `GRANT ALL PRIVILEGES ON \\*.* TO 'root'@'%' IDENTIFIED BY 'xxx';`：授权root用户远程登录，%表示不限IP\n11. `flush privileges;`：刷新权限\n12. `exit`：退出mysql\n13. `sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf`：更改配置文件中的bind-address为0.0.0.0\n14. `systemctl start mysql`：启动mysql服务\n\n#### mysql8.0\n\n其他步骤同5.7，授予权限不太相同\n\n`GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' WITH GRANT OPTION;`：授予root用户所有权限\n\n#### mysql\n\n`show tables;`：查看所有的表\n\n`describe 表名;`：查看该表结构\n\n`DROP TABLE table_name ;`：删除某张表\n\n`UPDATE <表名> SET 字段 1=值 1 [,字段 2=值 2… ] [WHERE 子句 ]`：修改某值\n\n\n\n# react项目服务器配置\n\n1. 应用本地打包\n\n   `mvn clean package`\n\n2. 本地包上传到服务器（U盘拷贝）\n\n   1.若在/usr文件夹下，需要超级权限才可以拷贝\n\n   2.启动超级权限`sudo nautilus`\n\n3. 服务器启动jar包\n\n   1.先删除之前进程\n\n   2.创建deploy.sh，把里面jar包名字替换为新上传的jar包\n\n   ![image-20201123225457860](C:\\Users\\Jet\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201123225457860.png)\n\n   3.运行脚本文件：sh deploy.sh\n\n4. 查看工程运行日志\n\n   - `tail -40f nohup.out`\n\n### 下载文件\n\n`sz 文件名 `：下载文件到本机\n\n`rz`：上传文件到服务器\n\n`zip -r filename.zip dirname`：打包文件夹\n\n### jar包命令\n\n1.jar包启动命令\n\n```java\njava -jar xxx.jar\n```\n\n2..修改项目启动端口号\n\n```java\njava -jar xxx.jar --server.port=8080 注释：将8080替换成自己想要的端口 \t\n```\n\n3.修改数据库连接配置\n\n```java\njava -jar xxx.jar --spring.datasource.url=“jdbc:mysql://localhost:3306/xxx?useUnicode=true&characterEncoding=utf-8&useSSL=true&serverTimezone=UTC” --spring.datasource.username=root --spring.datasource.password=123456\n注释：将root 以及123456替换成自己想要的数据库用户名以及密码即可\n```\n\n## windows\n\n### 接入网项目\n\n> nginx\n\n1. 去官网下载nginx并解压\n\n2. 在conf文件夹下的nginx.conf中修改配置文件\n\n3. 双击nginx.exe启动\n\n4. `tasklist /fi \"imagename eq nginx.exe\"`查看是否启动成功\n\n5. 关闭nginx：输入nginx命令  `nginx -s stop`(快速停止nginx)  或  `nginx -s quit`(完整有序的停止nginx)\n\n   或使用` taskkill /f /t /im nginx.exe`\n\n> 后端java\n\n1. 打出jar包\n\n2. 创建start.bat\n\n   ```bash\n   @echo off\n   start javaw demo.jar --server.port=8081 &\n   exit\n   ```\n\n3. 双击start.bat运行\n\n> 后端python\n\n1. 安装运行需要的包\n\n2. 创建start.bat\n\n   ```bash\n   @echo off\n   start /min app.py\n   exit\n   ```\n\n3. 双击start.bat运行\n\n\n\n","categories":["tech"]},{"title":"SQL","url":"/2022/09/27/数据库/","content":"\n# 数据库\n\n## SQL概念\n\n### 主键\n\n- 唯一标识表中每行的列才成为主键\n- 若多列作为主键，列值的组合必须是唯一的\n\n### 关键字顺序\n\n```mysql\nSELECT > DISTINCT > AS > FROM > WHERE > LIKE(REGEXP) > ORDER BY > BINARY > DESC(ASC) > LIMIT\n```\n\n![image-20210420121310952](C:\\Users\\Jet\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210420121310952.png)\n\n### 查看操作 SHOW\n\n`SHOW DATABASES`：查看数据库\n\n`SHOW TABLES`：查看表 \n\n`SHOW COLUMNS FROM TABLE`或`DES：查看某张表的列\n\n`SHOW STATUS`：显示广泛的服务器状态信息\n\n`SHOW CREATE DATABASE`：创建特定数据库\n\n`SHOW CREATE TABLE`：创建表\n\n`SHOW GRANTS`：显示授予用户\n\n`SHOW ERRORS`&`SHOW WARNINGS`：显示服务器错误或警告信息\n\n### 选择操作 SELECT\n\n`SELECT * FROM TABLE`：从表中选取所有列\n\n`SELECT DISTINCT id FROM TABLE`：从表中返回id列中不同的值**（DISTINCT)**\n\n`SELECT prod_name FROM products LIMIT 5`：返回不多于5行\n\n`SELECT prod_name FROM products LIMIT 5,5`：返回从行5开始的5行(从行0计数，行5为第六行)\n\n`SELECT products.prod_name FROM crashcourse.products`：完全限定表示\n\n> 排序\n\n`SELECT prod_id, prod_price, prod_name FROM products ORDER BY prod_price, prod_name`：检索三个列，先按prod_price排序，再按prod_name排序\n\n`SELECT prod_id, prod_price, prod_name FROM products ORDER BY prod_price DESC, prod_name ASC`：排序时按prod_price降序排序，按prod_name升序\n\n`SELECT prod_price FROM products ORDER BY prod_price DESC LIMIT 1`：找出最昂贵物品的价值\n\n> 过滤\n\n`SELECT prod_name, prod_price FROM products WHERE prod_price = 2.5`：检索prod_price为2.5的行\n\n`SELECT prod_name, prod_price FROM products WHERE prod_price between 5 AND 10`：检索prod_price在5和10之间的行（between）\n\n`SELECT prod_name FROM products WHERE prod_price IS NULL`：空值检查\n\n`SELECT prod_id, prod_price, prod_name FROM products WHERE vend_id =1003 AND prod_price <= 10`：AND语句检索条件\n\n`SELECT prod_id, prod_price, prod_name FROM products WHERE vend_id =1003 OR vend_id = 1003`：OR语句检索条件\n\n`SELECT prod_id, prod_price, prod_name FROM products WHERE (vend_id =1003 OR vend_id = 1003) AND prod_price >= 10`：组合使用\n\n`SELECT prod_id, prod_price, prod_name FROM products WHERE vend_id IN (1002,1003)`：IN操作语句，和OR等价，但更快更简洁\n\n`SELECT prod_id, prod_price, prod_name FROM products WHERE vend_id NOT IN (1002,1003)`：NOT操作语句\n\n### 通配符\n\n`SELECT prod_id, prod_name FROM products WHERE prod_name LIKE '%anvil%'`：LIKE语法，使用百分号%通配符可匹配任意字符\n\n`SELECT prod_id, prod_name FROM products WHERE prod_name LIKE '_ ton anvil'`：_下划线仅匹配一个字符\n\n### 正则表达式\n\n`SELECT prod_name FROM products WHERE prod_name REGEXP '1000' ORDER BY prod_name`：检索prod_name包含文本1000的所有行\n\n`REGEXP '.000'`：匹配任意一个字符\n\n`REGEXP BINARY 'Xxx'`：BINARY关键字可区分大小写\n\n`SELECT prod_name FROM products WHERE prod_name REGEXP '1000|2000' ORDER BY prod_name`：‘|’可以表示‘或’关系\n\n`SELECT prod_name FROM products WHERE prod_name REGEXP '[123] Ton' ORDER BY prod_name`：[123]表示1或2或3，[\\^123]表示除了这些字符外的任何东西。\\[0-9]表示匹配0-9之间任意数字，[a-z]表示匹配a-z之间任意数字\n\n匹配特殊字符必须加前置'\\\\\\\\'，如`REGEXP '\\\\.'`\n\n> 字符类\n\n| 类          | 说明                                      |\n| ---------- | --------------------------------------- |\n| [:alnum:]  | 任意字母和数字[a-zA-Z0-9]                      |\n| [:alpha:]  | 任意字符[a-zA-Z]                            |\n| [:blank:]  | 空格和制表[\\\\\\\\t]                            |\n| [:cntrl:]  | ASCII控制字符(ASCII 0到31和127)               |\n| [:digit:]  | 任意数字[0-9]                               |\n| [:graph:]  | 与[:print:]相同，但不包含空格                     |\n| [:lower:]  | 任意小写字母[a-z]                             |\n| [:print:]  | 任意可打印字符                                 |\n| [:punct:]  | 既不在[:alnum:]又不在[:cntrl:]中的任意字符          |\n| [:space:]  | 包括空格在内的任意空白字符[\\\\\\\\f\\\\\\\\n\\\\\\r\\\\\\\\t\\\\\\\\v] |\n| [:upper:]  | 任意大写字母[A-Z]                             |\n| [:xdigit:] | 任意十六进制数字[a-fA-F0-9]                     |\n\n> 重复元字符\n\n| 元字符   | 说明               |\n| ----- | ---------------- |\n| *     | 0或多个匹配           |\n| +     | 1个或多个匹配（等于{1,})  |\n| ?     | 0个或1个匹配（等于{0,1}) |\n| {n}   | 指定数目的匹配          |\n| {n,}  | 不少于指定数目的匹配       |\n| {n,m} | 匹配数目的范围          |\n\n`SELECT prod_name FROM WHERE prod_name REGEXP '[[:digit:]]{4}' ORDER BY prod_name`：匹配任意连在一起的4位数字\n\n> 定位元字符\n\n| 元字符     | 说明    |\n| ------- | ----- |\n| ^       | 文本的开始 |\n| $       | 文本的结尾 |\n| [[:<:]] | 词的开始  |\n| [[:>:]] | 词的结尾  |\n\n`'^[0-9\\\\.]'`：以一个数或小数点开始的字符串\n\n### 计算字段\n\n> 拼接Concat()\n\n`SELECT Concat(vend_name, '(' , vend_country, ')') FROM vendors ORDER BY vend_name`：Concat()拼接，各个串之间用逗号分隔\n\n> 去空格RTrim()、LTrim()、Trim()\n\n`SELECT Concat(RTrim(vend_name), '(' , vend_country, ')') FROM vendors ORDER BY vend_name`：RTrim用法\n\n> 别名（导出列）\n\n`SELECT Concat(RTrim(vend_name), '(' , vend_country, ')') AS vend_title FROM vendors ORDER BY vend_name`：创建一个包含指定计算的名为vend_title的计算字段\n\n> 执行算术计算\n\n`SELECTF prod_id,quantity,item_price,quantity*item_price AS expanded_price FROM orderitems WHERE order_num = 20005`：输出四列，最后一列是数量和价格相乘\n\n### 函数\n\n> 文本处理函数\n\n| 函数          | 说明           |\n| ----------- | ------------ |\n| Left()      | 返回串左边的字符     |\n| Length()    | 返回串的长度       |\n| Locate()    | 找出串的一个字串     |\n| Lower()     | 将串转换为小写      |\n| LTrim()     | 去掉串左边的空格     |\n| Right()     | 返回串右边的字符     |\n| RTrim()     | 去掉串右边的空格     |\n| Soundex()   | 返回串的SOUNDEX值 |\n| SubString() | 返回子串的字符      |\n| Upper()     | 将串转换为大写      |\n\n> 日期和时间处理函数\n\n| 函数            | 说明              |\n| ------------- | --------------- |\n| AddDate()     | 增加一个日期（天、周等）    |\n| AddTime()     | 增加一个时间（时、分等）    |\n| CurDate()     | 返回当前日期          |\n| CurTime()     | 返回当前时间          |\n| Date()        | 返回日期时间的日期部分     |\n| DateDiff()    | 计算两个日期之差        |\n| Date_Add()    | 高度灵活的日期运算函数     |\n| Date_Format() | 返回一个格式化的日期或时间串  |\n| Day()         | 返回一个日期的天数部分     |\n| DayOfWeek()   | 对于一个日期，返回对应的星期几 |\n| Hour()        | 返回一个时间的小时部分     |\n| Minute()      | 返回一个时间的分钟部分     |\n| Month()       | 返回一个日期的月份部分     |\n| Now()         | 返回当前日期和时间       |\n| Second()      | 返回一个时间的秒部分      |\n| Time()        | 返回一个日期时间的时间部分   |\n| Year()        | 返回一个日期的年份部分     |\n\n> 数值处理函数\n\n| 函数     | 说明        |\n| ------ | --------- |\n| Abs()  | 返回一个数的绝对值 |\n| Cos()  | 返回一个角度的余弦 |\n| Exp()  | 返回一个数的指数值 |\n| Mod()  | 返回除操作的余数  |\n| Pi()   | 返回圆周率     |\n| Rand() | 返回一个随机数   |\n| Sin()  | 返回一个角度的正弦 |\n| Sqrt() | 返回一个数的平方根 |\n| Tan()  | 返回一个角度的正切 |\n\n> 聚集函数\n\n| 函数      | 说明       |\n| ------- | -------- |\n| AVG()   | 返回某列的平均值 |\n| COUNT() | 返回某列的行数  |\n| MAX()   | 返回某列的最大值 |\n| MIN()   | 返回某列的最小值 |\n| SUM()   | 返回某列量之和  |\n\n`SELECT AVG(DISTINCT prod_price) AS ag_price FROM products WHERE vend_id = 1003`：**DISTINCT**后置不能跟*\n\n> 组合聚集函数\n\n```mysql\nSELECT \nCOUNT(*) AS num_items,\nMIN(prod_price) AS price_min,\nMAX(prod_price) AS price_max,\nAVG(prod_price) AS price_avg \nFROM products;\n```\n\n### 分组汇总GROUP BY\n\n`select vend_id, count(*) as num_prods from products group by vend_id with rollup;`：**WITH ROLLUP** 可以统计汇总值\n\n> 过滤分组HAVING\n\n`SELECT cust_id, count(*) AS orders FROM orders GROUP BY cust_id HAVING COUNT(\\*) >= 2`：**WHERE**在分组前过滤，**HAVING**在分组后过滤\n\n> 双重过滤\n\n`SELECT vend_id, count(*) AS num_prods FROM products WHERE prod_price >= 10 GROUP BY vend_id HAVING COUNT(\\*) >= 2`：列出具有2个（含）以上、价格为10（含）以上的产品的供应商\n\n### 联结\n\n> 主键\n\n唯一标识\n\n> 外键\n\n其他表的主键\n\n> 等值联结（内部联结）\n\n`SELECT vend_name, prod_name, prod_price FROM vendors, products WHERE vendors.vend_id = products.vend_id ORDER BY vend_name, prod_name`：通过WHERE创建联结，否则会返回笛卡尔积\n\n`SELECT vend_name, prod_name, prod_price FROM vendors INNER JOIN products ON vendors.vend_id = products.vend_id`\n\n> 自联结\n\n`SELECT p1.prod_id, p1.prod_name FROM products AS p1, products AS p2 WHERE p1.vend_id = p2.vend_id AND p2.prod_id = 'DTNTR'`：自联结需要起表别名\n\n> 自然联结\n\n> 外部联结\n\n`SELECT customers.cust_id, orders.order_num FROM customers LEFT OUTER JOIN orders ON customers.cust_id = orders.cust_id`：(LEFT\\\\RIGHT) OUTER JOIN 是外部联结，left表示选择左边表的所有行，right表示选择右边表的所有行。\n\n> 表别名\n\n`FROM customers AS c, orders AS o, orderitems AS oi`：表别名只在查询执行中使用不返回到客户机\n\n### 组合查询\n\n> UNION\n\n```mysql\nSELECT vend_id, prod_id, prod_price\nFROM products\nWHERE prod_price <= 5\nUNION\nSELECT vend_id, prod_id, prod_price\nFROM products\nWHERE vend_id IN (1001,1002);\n/******************/\nSELECT vend_id, prod_id, prod_price\nFROM products\nWHERE prod_price <= 5\nOR vend_id IN (1001,1002)\n```\n\n规则：1、UNION必须由两条或两条以上SELECT语句组成；2、UNION中每个查询必须包含相同的列、表达式或聚集函数；3、列数据必须兼容\n\n注意：对组合查询进行排序，ORDER BY子句必须出现在最后一条SELECT语句之后\n\n> UNION ALL\n\n不过滤重复行\n\n### 全文本搜索\n\n支持引擎：MyISAM\n\n不支持：InnoDB\n\n在创建表时需要使用`FULLTEXT(column_name)`来建立索引\n\n`SELECT note_text FROM productnotes WHERE Match(note_text) Against('rabbit')`：Match中填写和FULLTEXT中的一致，Against中填写需要匹配的词，返回匹配的行\n\n> 查询扩展\n\n```MYSQL\nSELECT note_text FROM productnotes WHERE Match(note_text) Against('anvils' WITH QUERY EXPANSION);\n```\n\n增加返回行数，匹配相近行\n\n> 布尔文本搜索\n\n```mysql\nSELECT note_text\nFROM productnotes\nWHERE Match(note_text) Against('heavy -rope*' IN BOOLEAN MODE);\n```\n\n| 布尔操作符 | 说明        |\n| ----- | --------- |\n| +     | 包含，词必须存在  |\n| -     | 排除，词必须不出现 |\n| >     | 包含，且增加等级值 |\n| <     | 包含，且减少等级值 |\n| ()    | 把词组成子表达式  |\n| ~     | 取消一个词的排序值 |\n| *     | 词尾的通配符    |\n| \"\"    | 定义一个短语    |\n\n### 插入数据\n\n```mysql\nINSERT INTO customers(cust_name,cust_address,cust_city,cust_state,cust_country,cust_contact,cust_email)\nVALUES('Pep E. LaPew','100 Main Street','Los Angeles','CA','90046','USA',NULL,NULL);\n```\n\n> INSERT SELECT\n\n```mysql\nINSERT INTO customers(cust_id,cust_contact)\nSELECT cust_id,cust_contact FROM custnew;\n```\n\n### 更新和删除数据\n\n> UPDATE\n\n```mysql\nUPDATE IGNORE customers\nSET cust_email = 'elmer@fudd.com'\nWHERE cust_id = 10005;\n```\n\n> DELETE\n\n```mysql\n/*删除行*/\nDELETE FROM customers\nWHERE cust_id = 10005;\n/*删除表*/\nTRUNCATE TABLE\n```\n\n### 表操作\n\n#### 创建表\n\n```mysql\nCREATE TABLE vendors IF NOT EXISTS\n(\n    vend_id    int      NOT NULL AUTO_INCREMENT,\n    order_date datetime NOT NULL,\n    cust_id    int      NOT NULL,\n    quantity   int      NOT NULL DEFAULT 1,\n    PRIMARY KEY (order_num)\n) ENGINE=InnoDB\n\n/*确定 AUTO_INCREMENT 值*/\nSELECT last_insert_id()\n```\n\n#### 更新表\n\n```mysql\n/*给表添加一个列*/\nALTER TABLE vendors\nADD vend_phone CHAR(20);\n/*删除刚刚添加的列*/\nALTER TABLE vendors\nDROP COLUMN vend_phone;\n/*定义外键*/\nALTER TABLE orderitems\nADD CONSTRAINT fk_orderitems_orders\nFOREIGN KEY (order_num) REFERENCES orders (order_num);\n```\n\n#### 删除表\n\n```mysql\nDROP TABLE customer32;\n```\n\n#### 重命名表\n\n```mysql\nRENAME TABLE customers2 TO customers;\n```\n\n### 引擎\n\n`InnoDB`：可靠的事务处理引擎，不支持全文本搜索；开销大，加锁慢，会出现死锁；锁定粒度最小，发生锁冲突的概率也最低，并发度最高，支持行级锁\n\n`MEMORY`：功能等同于MyISAM，数据存储在内存中，速度很快，特别适合于临时表；开销小，加锁快；无死锁，锁定粒度大，发生锁冲突概率高，并发度最低\n\n`MyISAM`：性能极高，支持全文本搜索，不支持事务处理\n\n![image-20210420114802810](C:\\Users\\Jet\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210420114802810.png)\n\n### 视图\n\n```mysql\n/*创建视图*/\nCREATE VIEW XXX AS ...\n/*查看视图*/\nSHOW CREATE VIEW viewname\n/*删除视图*/\nDROP XXXX\n/*更新视图*/\nCREATE OR REPLACE VIEW\n```\n\n```MYSQL\n/*创建视图例子*/\nCREATE VIEW productcustomers AS \nSELECT cust_name, cust_contact, prod_id\nFROM customers, orders, orderitems\nWHERE customers.cust_id = orders.cust_id\n    AND orderitems.order_num = orders.order_num;\n/*使用视图例子*/    \nSELECT cust_name, cust_contact\nFROM productcustomers\nWHERE prod_id = 'TNT2';    \n```\n\n> 更新视图\n\n如果视图定义有以下操作，则不能进行视图的更新\n\n1. 分组（使用GROUP BY 和HAVING）\n2. 联结\n3. 子查询\n4. 并\n5. 聚集函数（Min()、Count()、Sum()等）\n6. DISTINCT\n7. 导出（计算列）\n\n### 存储过程\n\n```mysql\n/*创建存储过程*/\n/*当使用mysql命令行客户机时，‘；’分隔符在存储过程内会被解释，而无法成为存储过程的成分*/\nDELIMITER //\nCREATE PROCEDURE productpring(\n    OUT p1 DECIMAL(8,2)\n    OUT ph DECIMAL(8,2)\n    OUT pa DECIMAL(8,2))\nBEGIN\n    SELECT Min(prod_price)\n    INTO p1\n    FROM products;\n    SELECT Max(prod_price)\n    INTO ph\n    FROM products;\n    SELECT Avg(prod_price)\n    INTO pa\n    FROM products;\nEND //\n/*DELIMITER //将//作为新的语句结束分隔符，只有\\符号无法作为语句分隔符*/\n\n/*调用存储过程,需要传参*/\nCALL productpricing(@pricelow,\n                       @pricehigh,\n                       @priceaverage);\n\n/*删除存储过程*/\nDROP PROCEDURE productpricing;\n\n/*检查存储过程*/\nSHOW CREATE PROCEDURE ordertotal;\n```\n\n> 存储完整过程\n\n```mysql\n-- Name:ordertotal\n-- Parameters: onumber = order number\n--             taxable = 0 if not taxable, 1 if taxable\n--             ototal  = order total variable\n\nCREATE PROCEDURE ordertotal(\n    IN onumber INT,\n    IN taxable BOOLEAN,\n    OUT ototal DECIMAL(8,2)\n) COMMENT 'Obtain order total, optionally adding tax'\nBEGIN\n    -- Declare variable for total \n    DECLARE total DECIMAL(8,2);\n    -- Declare tax percentage\n    DECLARE taxrate INT DEFAULT 6;\n\n    --Get the order total\n    SELECT Sum(item_price*quantity)\n    FROM orderitems\n    WHERE order_num = onumber\n    INTO total;\n\n    -- Is this taxable?\n    IF taxable THEN\n        -- Yes, so add taxrate to the total\n        SELECT total+(total/100*taxrate) INTO total;\n    END IF;\n\n    -- And finally, save to out variable\n    SELECT total INTO ototal;\nEND;\n```\n\n`COMMENT`：表示注释\n\n`DECIMAL(8,2)`：8表示总共8位数，2表示后两位为小数\n\n### 游标\n\n```mysql\n-- 开启游标\nOPEN cursorname;\n-- 关闭游标\nClose cursorname;\n\n/*实例*/\nCREATE PROCEDURE processorders()\nBEGIN\n\n    -- Declare local variables\n    DECLARE done BOOLEAN DEFAYLT 0;\n    DECLARE o INT;\n    DECLARE t DECIMAL(8,2);\n\n    -- Declare the cursor\n    DECLARE ordernumbers CURSOR\n    FOR \n    SELECT order_num FROM orders;\n\n    -- Declare continue handler \n    DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done=1;\n\n    -- Create a table to store the results\n    CREATE TABLE IF NOT EXISTS ordertotals\n        (order_num INT, total DECIMAL(8,2));\n\n    -- Open the cursor\n    OPEN ordernumbers;\n\n    -- Loop through all rows\n    REPEAT\n\n        -- Get order number\n        DETCH ordernumbers INTO o;\n\n        -- Get the total for this order\n        CALL ordertotal(o,1,t);\n\n        -- Insert order and total into ordertotals\n        INSERT INTO ordertotals(order_num, total)\n        VALUES(o,t);\n\n    -- End of loop\n    UNTIL done END REPEAT;\n\n    --Close the cursor;\n    CLOSE ordernumbers;\nEND;\n```\n\n`SQLSTATE '02000'`：是一个未找到条件时的状态\n\n### 触发器\n\n触发器响应以下指令\n\n1. DELETE\n2. INSERT\n3. UPDATE\n\n```mysql\n-- 创建触发器,将信息存入asd变量中，使用SELECT @asd;查看\nCREATE TRIGGER newproduct AFTER INSERT ON products\nFOR EACH ROW SELECT 'Product added' INTO @asd;\n\n-- INSERT触发器，返回新生成的订单号\nCREATE TRIGGER neworder AFTER INSERT ON orders\nFOR EACH ROW SELECT NEW.order_num;\n\n-- DELETE触发器,OLD是只读表，访问将被删除的行\nCREATE TRIGGER delteorder BEFORE DELETE ON orders\nFOR EACH ROW\nBEGIN\n    INSERT INTO archive_orders(order_num, order_date, cust_id)\n    VALUES(OLD.roder_num, OLD.order_date, OLD.cust_id);\nEND;\n\n-- UPDATE触发器，OLD虚拟表可访问更新前的值，NEW虚拟表访问更新后的值\nCREATE TRIGGER updatevendor BEFORE UPDATE ON venders\nFOR EACH ROW SET NEW.vend_state = Upper(New.vend_state)\n\n-- 删除触发器\nDROP TRIGGER newproduct;\n\n--\n```\n\n### 事务处理\n\n事务（transactioin）：指一组SQL语句\n\n回退（rollback）：指撤销指定SQL语句的过程\n\n提交（commit）：指将未存储的SQL语句结果写入数据库表\n\n保留点（savepoint）：指事务处理中设置的临时占位符，可以对其发布回退\n\n```mysql\n-- ROLLBACK\n-- 开启事务处理，可通过ROLLBACK撤销其中的INSERT,UPDATE和DELETE语句\nSTART TRANSACTION;\nDELETE FROM ordertotals;\nROLLBACK;\n\n-- COMMIT，在事务处理中必须主动提交，才会生效，若第二条delete失败，则前面的delete也自动撤销\nSTART TRANSACTION\nDELETE FROM orderitems WHERE order_num = 20010;\nDELETE FROM orders WHERE order_num = 20010;\nCOMMIT\n\n-- SAVEPOINT，支持部分回退\nSAVEPOINT delete1;\nROLLBACK TO delete1;\n```\n\n### 安全管理\n\n> 用户管理\n\n```mysql\n-- 创建用户账号\nCREATE USER ben IDENTIFIED BY 'password';\n\n-- 重命名\nRENAME USER ben TO bfota\n\n-- 删除用户\nDROP USER bfota;\n\n-- 查看用户权限\nSHOW GRANTS FOR bfota;\n\n-- 设置用户权限, 允许用户在crashcourse数据库的所有表上使用SELECT\nGRANT SELECT ON crashcourse.* TO bfota;\n\n-- 撤销用户权限\nREVOKE SELECT ON crashcourse.* FROM bfota;\n\n-- 更改口令\nSET PASSWORD FOR bfota = Password('n3dsifnfea');-- 为他人更改\nSET PASSWORD = Password('lfasdfasd');-- 为自己更改\n```\n\n### 数据库维护\n\n> 备份数据\n\n备份前需要先`FLUSH TABLES`来刷新未写数据\n\n1. `mysqldump`：转储所有数据库内容到某个外部文件\n2. `mysqlhotcopy`：从一个数据库复制所有数据\n3. BACKUP TABLE`或`SELECT INTO OUTFILE`：转储所有数据到某个外部文件，给出文件名，且文件不能已存在，可以使用`RESTORE`恢复\n\n> 维护\n\n1. `ANALYZE TABLE orders`：检查表键是否正确\n2. `CHECK TABLE orders`：检查表的各种问题\n\n> 日志\n\n- 错误日志，hostname.err\n- 查询日志，hostname.log\n- 二进制日志，hostname-bin\n- 缓慢查询日志，hostname-slow.log\n\n刷新日志：`FLUSH LOGS`\n\n### 改善性能\n\n查看当前设置：\n\n`SHOW VARIABLES`\n\n`SHOW STATUS`\n\n显示所有活动线程：\n\n`SHOW PROCESSLIST`\n\n## csv文件的导入导出\n\n```mysql\n--加载数据到建好的数据库表中\nLOAD data infile 'D:/ProgramData/MySQL/MySQL Server 8.0_data/Uploads/jl_dl_.csv' into table jl_dl_ fields terminated by ',' IGNORE 1 LINES;\nLOAD data infile 'D:/ProgramData/MySQL/MySQL Server 8.0_data/Uploads/resource.csv' into table resource fields terminated by ',' IGNORE 1 LINES;\n--输出查询结果到csv文件中,带表名\nSELECT\n    'NMS_ORIG_RES_ID'                 ,\n    'CARD_ID'                         ,\n    'SUPER_RES_ID'                    ,\n    'SUPER_RES_POSITION_ID'           ,\n    'MANAGE_IPADDRESS'              ,\n    'EMS_ORIG_RES_NAME'               ,\n    'TECHNICAL_MODE'                  ,\n    'BROADBAND_SUB'                   ,\n    'IPTV_SUB'                        ,\n    'identityVOIP_SUB'                ,\n    'BROADBAND_FTTH_NUM'              ,\n    'BROADBAND_FTTB_LAN_NUM'          ,\n    'BROADBAND_FTTB_DSL_NUM'          ,\n    'BROADBAND_FTTH_PORTNUM'          ,\n    'BROADBAND_FTTB_LAN_PORTNUM'      ,\n    'BROADBAND_FTTB_DSL_PORTNUM'      ,\n    'BROADBAND_FTTH_ONTNUM'           ,\n    'BROADBAND_FTTB_LAN_USEDPORTNUM'  ,\n    'BROADBAND_FTTB_DSL_USEDPORTNUM'  ,\n    'BROADBAND_BELOW_10M_NUM'         ,\n    'BROADBAND_BELOW_20M_NUM'         ,\n    'BROADBAND_BELOW_50M_NUM'         ,\n    'BROADBAND_BELOW_100M_NUM'        ,\n    'BROADBAND_BELOW_200M_NUM'        ,\n    'BROADBAND_BELOW_300M_NUM'        ,\n    'BROADBAND_BELOW_500M_NUM'        ,\n    'BROADBAND_BELOW_1000M_NUM'       ,\n    'BROADBAND_ABOVE_1000M_NUM'       ,\n    'ADDR_FROM'                       ,\n    'STAND_NAME'\nunion select *\nfrom jl_dl_\ninto outfile 'D:/ProgramData/MySQL/MySQL Server 8.0_data/Uploads/1.csv'\nCHARACTER SET gbk FIELDS TERMINATED BY ',';\n```\n\n## 创建相同结构表\n\n```mysql\ncreate table A\ndefault charset = utf8 comment 'xxx'\nas select * from B where 1=2;\n```\n\n## case when\n\nhttps://www.cnblogs.com/yazdao/archive/2009/12/09/1620482.html\n\n## 常用指令\n\n```mysql\n//查看存储引擎\nshow variables like '%storage_engine%';\n//查看字符集\n show variables like '%char%';\n show variables like 'names%';\n //查看安全路径\n show variables like 'secure_file_priv';\n```\n\n# 高级mysql\n\n- mysql内核\n- sql优化工程师\n- mysql服务器的优化\n- 各种参数常量设定\n- 查询语句优化\n- 主从复制\n- 软硬件升级\n- 容灾备份\n- sql编程\n\n## 索引\n\n> 单值索引\n\n```mysql\nselect * from user where name = '';\ncreate index idx_user_name on user(name);\n```\n\n> 复合索引\n\n```mysql\nselect * from user where name = '' and email = '';\ncreate index idx_user_nameEmail on user(name,Email);\n```\n\n### 索引的优劣\n\n原理：B+树（多路搜索树），有聚集索引、次要索引、复合索引、前缀索引，唯一索引等，还有哈希索引\n\n索引：排好序的快速查找数据结构\n\n优势：\n\n- 类似大学图书馆建书目索引，提高数据检索的效率，降低数据库IO成本\n\n- 通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗\n\n劣势：\n\n- 占用空间\n- 降低更新表速度，（插入、更新、删除）\n\n索引分类：\n\n- 单值索引：一个索引只包含单个列，一个表可以有多个单列索引（建议5个）\n- 唯一索引：索引列的值必须唯一，但允许有空值\n- 符合索引：一个索引包含多个列\n\n基本语法：\n\n```mysql\n//创建索引\nCREATE [UNIQUE] INDEX indexName ON mytable(columnname(length));\nALTER mytable ADD [UNIQUE] INDEX [indexName] ON (columnname(length));\n\n//添加主键，主键就是唯一索引\nALTER TABLE table ADD PRIMARY KEY(column_list);\n\n//全文索引\nALTER TABLE table ADD FULLTEXT index_name(column_list);\n\n//删除索引\nDROP INDEX [indexName] ON mytable;\n\n//查看索引\nSHOW INDEX FR OM table_name;\n```\n\n创建索引情况：\n\n- 主键自动建立唯一索引\n- 频繁作为查询条件的字段应该创建索引\n- 查询中与其他表关联的字段，外键关系建立索引\n- 频繁更新的字段不适合创建索引\n- where条件里用不到的字段不创建索引\n- 在高并发下倾向创建组合索引\n- 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度\n- 查询中统计或分组字段\n\n不需创建索引：\n\n- 表记录太少\n- 经常增删改的表\n- 数据重复且分布平均的表字段\n\n### 防止索引失效\n\n- 左前缀法则：若索引多列，则遵循从左到右查询，不跳过\n\n- 不在索引上做任何操作（计算、函数、类型转换）\n  \n  ```MYSQL\n  //name为索引列\n  select * from staffs where left(name,4) = 'july';\n  ```\n\n- 存储引擎不能使用索引中范围条件右边的索引列\n\n- 尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致））\n\n- mysql在使用不等于（!=或<>）的时候无法使用索引会导致全表扫描\n\n- is null, is not null 也无法使用索引而导致全表扫描\n\n- like以通配符开头(''%abc...')会导致索引失效而导致全表扫描\n  \n  ```mysql\n  -- 解决like'%字符串%'时索引不被使用的方法？\n  使用覆盖索引\n  ```\n\n- 字符串不加单引号索引失效（产生类型转换）\n\n- 少用OR，用它连接时会导致索引失效\n\n## 性能优化\n\n> MySQL Query Optimizer\n\n> MySQL 常见瓶颈\n\n- CPU：饱和时\n- IO：磁盘装入数据远大于内存容量时\n- 服务器硬件性能：`top`、`free`、`iostat`、`vmstat`来查看系统的性能状态\n\n### 查看当前sql语句性能\n\n> EXPLAIN\n\n使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MYSQL是如何处理你的SQL语句的，分析查询语句或是表结构的性能瓶颈\n\n可看到信息：\n\n- 表执行顺序\n\n- 数据读取操作的操作类型（sekect_type）\n\n- 哪些索引可以被使用\n\n- 哪些索引被实际引用\n\n- 表之间的引用\n\n- 每张表有多少行被优化器查询\n\n![image-20210420180237922](C:\\Users\\Jet\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210420180237922.png)\n\n- id\n  \n  - id相同，执行顺序由上至下\n  - id不同，若子查询，id序号递增，id越大执行优先级越高\n  - id相同和不同，同时存在\n\n- select_type\n  \n  - simple：简单的select查询，不包含子查询和union\n  \n  - primary：最外层查询\n  \n  - subquery：子查询\n  \n  - derived：子查询被标记为derived\n  \n  - union：若第二个select出现在union之后，则被标记为union，若union包含在from子句的子查询中，外层select将被标记为：derived\n  \n  - union result：union获取结果的select\n\n- type\n  \n  ​    显示查询使用了何种类型，从最好到最差依次是\n  \n  ​    system>const>eq_ref>ref>range>index>ALL\n  \n  - system ：表只有一行记录（等于系统表）\n  - const：通过索引一次就找到了，只匹配一行数据\n  - eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描\n  - ref：非唯一性索引扫描，返回匹配某个单独值的所有行\n  - range：只检索给定范围的行，使用一个索引选择行。key列显示使用了哪个索引，一般就是在你的where语句红出现了between、<、>、in等的查询，比全表扫描好\n  - index：只遍历索引树。 \n\n- possible_keys：显示可能应用在这张表中的索引，一个或多个，不一定被查询实际使用\n\n- key：实际使用的索引，如果为NULL，则没有使用索引，查询中若使用了覆盖索引，则该索引仅出现在key列表中。\n\n- key_len：表示索引中使用的字节数，索引中使用的字节数，保证精确性情况下，长度越短越好，该值表示索引字段最大可能长度，并非实际使用长度。\n\n- ref：显示索引的哪一列被使用了\n\n- rows：根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数\n\n- extra：包含不适合在其他列中显示但十分重要的额外信息\n  \n  - Using filesort：不按照表内索引顺序读取，自己又产生了一次排序，需要优化，危险\n  - Using temporary：新建了临时表，常见于order by和group by，非常危险\n  - Using index：表示响应select操作中使用了覆盖索引，避免访问了表的数据行，效率不错，如果同时出现了Using where，表明索引被用来执行索引键值的查找，如果没有出现，则表明索引用来读取数据而非执行查找动作。\n  - Using where：使用了where查询\n  - Using join buffer：使用了连接缓存\n  - impossible where：where子句的值总是false，不能获取任何元组\n  - select tables optimized away：在没有GROUPBY子句情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化\n  - distinct：优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作。\n\n> show profile\n\n分析当前会话中sql语句执行的资源消耗情况的工具\n\n```mysql\n//执行一条sql语句后\nshow profiles;\n//出现\nshow profile cpu,block io for query Query_ID;\n/*Query_ID为#上步骤中show profiles列表中的Query_ID*/\n```\n\n- show profile的常用查询参数。\n\n①ALL：显示所有的开销信息。\n\n②BLOCK IO：显示块IO开销。\n\n③CONTEXT SWITCHES：上下文切换开销。\n\n④CPU：显示CPU开销信息。\n\n⑤IPC：显示发送和接收开销信息。\n\n⑥MEMORY：显示内存开销信息。\n\n⑦PAGE FAULTS：显示页面错误开销信息。\n\n⑧SOURCE：显示和Source_function，Source_file，Source_line相关的开销信息。\n\n⑨SWAPS：显示交换次数开销信息。\n\n- 日常开发需注意的结论。\n\n①converting HEAP to MyISAM：查询结果太大，内存不够，数据往磁盘上搬了。\n\n②Creating tmp table：创建临时表。先拷贝数据到临时表，用完后再删除临时表。\n\n③Copying to tmp table on disk：把内存中临时表复制到磁盘上，危险！！！\n\n④locked。\n\n如果在show profile诊断结果中出现了以上4条结果中的任何一条，则sql语句需要优化。\n\n### 优化建议\n\n#### 小表驱动大表\n\n优化原则，使用小的数据集驱动大的数据集\n\n```mysql\n//当B的数据集小于A的数据集时，用in优于exists\nselect* from A where id in (select id from B)\n等价于:\nfor select id from B\nfor select * from A where A.id = B.id\n\n//当A的数据集小于B的数据集时，用exists优于in\nselect * from A where exists (select 1 from B wehre B.id = A.id)\n等价于：\nfor select * from A\nfor select * from B where B.id = A.id\n```\n\n#### order by和group by\n\n- 尽量用`using index`方式排序，避免用`using filesort`方式排序\n\n- 遵循索引键的最佳左前缀\n\n- filesort有两种算法，单路排序和双路排序\n  \n  - 双路排序：从磁盘读取排序字段，在buffer进行排序，再从磁盘读取其他字段\n  - 单路排序：从磁盘读取所有字段，在buffer对排序字段排序，避免了第二次读取数据，但占用内存多。\n  - 存在问题：单路为后出的算法，性能更好。但是受限于sort_buffer容量，可能出现更多次I/O操作\n\n- 优化策略：\n  \n  - order by时尽量不用 select *\n    \n    当Query字段大小总和小于max_length_for_sort_data而且排序字段不是TEXT|BLOB类型时，会用单路排序，否则使用多路排序；\n    \n    两种算法数据都有可能超出sort_buffer的容量，超出后会创建tmp文件进行合并排序，导致多次I/O，要提高sort_buffer_size\n  \n  - 提高sort_buffer_size\n  \n  - 提高max_length_for_sort_data，越大越有可能采用单路排序，但也更有可能超出sort_buffer_size，影响为高磁盘I/O活动和低处理器使用率\n  \n  where高于having，能用where不用having\n\n## 慢查询日志\n\n默认不开启，开启有性能影响，仅在调参时使用\n\n开启只对当前数据库生效，重启MySQL后会失效\n\n```mysql\n//查看是否开启\nSHOW VARIABLES LIKE '%slow_query_log%';\n//开启\nset global slow_query_log=1;\n```\n\n设置慢查询阈值（运行时间大于该阈值会被记录）\n\n```mysql\nSHOW VARIABLES LIKE 'long_query_time%'; -- 单位为秒\n```\n\nmysql日志分析（mysqldumpslow）\n\n```mysql\n-- 得到返回记录集最多的10个SQL\nmysqldumpslow -s r -t 10 /var/lib/mysql/xxx.log | more\n-- 得到访问次数最多的10个SQL\nmysqldumpslow -s c -t 10 /var/lib/mysql/xxx.log | more\n-- 得到按照时间排序的前10条里面含有左连接的查询语句\n mysqldumpslow -s t -t 10 -g \"left join\" /var/lib/mysql/xxx.log | more\n```\n\n## 全局日志\n\n```mysql\nset global general_log=1;\nset global log_output='TABLE';\nselect * from mysql.general_\n```\n\n## 语句操作顺序\n\n> 手写\n\n![image-20210420121053777](C:\\Users\\Jet\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210420121053777.png)\n\n> 机读\n\n![image-20210420121125443](C:\\Users\\Jet\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210420121125443.png)\n\n## 七种JOIN\n\n![image-20210420121822785](C:\\Users\\Jet\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210420121822785.png)\n\n![image-20210420122153491](C:\\Users\\Jet\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210420122153491.png)\n\n## MySQL锁机制\n\n从对数据操作的类型分：\n\n- 读锁（共享锁），加读锁后，本进程只能读被锁表，且不可写，其它进程可读该表，但是写的话会阻塞。\n- 写锁（排他锁），加写锁后，本进程只可读可写被锁表，其他表对该表不可操作\n\n读锁阻塞写但不阻塞读，而写锁会把读和写都阻塞\n\n```mysql\n-- 手动增加表锁\nlock table 表名read(write),表名read(wirte)，其它;\n-- 查看表上加过的锁\nshow open tables;\n-- 解锁表\nunlock tables;\n-- 分析表锁定\nshow status like 'table%';\n```\n\nTable_locks_immediate：产生表级锁定的次数，表示可以立即获取锁的查询次数\n\nTable_locks_waited：出现表级锁定争用而发生等待的次数（不能立即获取锁的次数）\n\n### 并发事务处理问题\n\n- 更新丢失（Lost Update）\n- 脏读（Dirty Reads）\n- 不可重复读（Non-Repeatable Reads）\n- 幻读（Phantom Reads）\n\n### 数据库的事务隔离级别\n\n![image-20210518122244917](C:\\Users\\Jet\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210518122244917.png)\n\n```mysql\n-- 查看当前数据库的事务隔离级别\nshow variables like 'tx_isolation';\n-- 设置数据库事务隔离级别\nset transaction isolation level read committed;\n```\n\n### 行锁\n\n索引失效，行锁会变表锁\n\n### 间隙锁\n\n> 概念\n\n使用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP）”，\n\nInnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）\n\n> 危害\n\n因为Query执行过程中通过范围查找的话，会锁定整个范围内所有的索引键值，即使这个键值并不存在。\n\n间隙锁有一个比较致命的弱点，就是当锁定一个范围键值后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害。\n\n### 如何锁定一行\n\n```mysql\n-- 锁定该行，用for update\nselect * from table where a=8 for update;\n```\n\n### 分析行锁定\n\n通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况\n\n```mysql\nshow status like 'innodb_row_lock%';\n```\n\n- Innodb_row_lock_current_waits：当前正在等待锁定的数量\n- Innodb_row_lock_time：从系统启动到现在锁定总时间长度*\n- Innodb_row_lock_time_avg：每次等待所花平均时间*\n- Innodb_row_lock_time_max：从系统启动到现在等待最长的一次所花的时间\n- Innodb_row_lock_waits：系统启动后到现在总共等待的次数*\n","categories":["tech"]},{"title":"Win10下，pyTorch深度学习环境搭建心得","url":"/2022/09/27/Win10下，pyTorch深度学习环境搭建心得/","content":"\n# Win10下，pyTorch深度学习环境搭建心得\n\n搭建windows下python深度学习基础环境\n\n目前共需要三个基础的需要安装的工具\n\n1.Anaconda 2.pyTorch 3.Cuda+Cudnn\n\n接下来介绍从零开始配置环境\n\n## 1. Anaconda的安装\n\n​        我的电脑上已经先安装过了python3.7，一开始我并不想安装anaconda，本意尽量从简，但是pip并没有想象中好用，并不能快速安装我需要的包，所以选择使用conda。对于conda，有两个选择，一个是Anaconda，一个是Miniconda。后者是前者的精简版，只有conda的包管理功能，没有主界面等，简单说就是让你可以在命令行用conda的指令，对我来说足够了，所以我选择安装miniconda。\n\n> **下载地址**\n\n官方网站：<https://docs.conda.io/en/latest/miniconda.html>\n\n清华镜像：<https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/>\n\n---\n\n​        下载好之后进行安装，可以一路默认直到`Advanced Options`，这里建议不要勾选`Add Anaconda to my PATH environment variable`，勾选`Register Anaconda as my default Python`，因为Anaconda的python是在虚拟环境中使用的，如果勾选第一项会导致你在cmd中输入python会有警告，然后继续安装即可\n\n安装好后在环境变量中添加三个路径，已经有的话就不用了\n\n```mark\nC:\\Users\\Administrator\\Miniconda3； \nC:\\Users\\Administrator\\Miniconda3\\Scripts； \nC:\\Users\\Administrator\\Miniconda3\\Library\\bin \n```\n\n至此，conda算是安装好了，接下来就可以利用conda来安装其他你需要的包了\n\n## 2. pyTorch的安装\n\n​        首先到官方网站<https://pytorch.org/>，得到关于你的配置下的pyTorch安装指令，比如我的是`windows10+conda+python+Cuda10.1`，就得到了这样的指令`conda install pytorch torchvision cudatoolkit=10.1 -c pytorch`，注意讲后面的-c python去掉（我也不懂，去掉就是了），接着最保险的安装方法是打开Anaconda Prompt操作台，类似于cmd（已经安装了miniconda，所以会有这个程序）\n\n* 对于国内用户推荐，首先给Anaconda添加清华镜像\n\n```mark\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/\nconda config --set show_channel_urls yes\n```\n\n- 接下来执行之前得到的指令来安装pyTorch即可\n\n---\n\n​        安装完成后可以关闭，打开cmd，创建一个带有pytorch包的虚拟环境，指令如下`conda create -n your_envname python=3.7 pytorch`，创建完成后，使用`conda activate your_envname`来打开该虚拟环境，然后输入python，打开python，接着输入`import torch`来查看pyTorch是否安装成功并可以使用，至此，pytorch的安装告一段落。其他包的安装可以借鉴此过程\n\n- 其实也可以先创建环境，再在该环境下安装pyTorch包，效果是一样的\n\n## Cuda+Cudnn的安装\n\n​        先下载Cuda，到官网下载<https://developer.nvidia.com/>，根据配置选择相应版本下载。安装直接一路默认即可\n\n---\n\n​        再下载Cudnn，<https://developer.nvidia.com/rdp/cudnn-download>，需要注册一个Nivida账号，选择相应版本下载 \n\n1. 下载完成后得到一个压缩包，将其解压，找到文件夹'cuda'打开，你会发现三个文件夹'bin'、'include'、'lib'\n\n2. 打开CUDA安装路径\n   `C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA `\n   发现有同名的三个文件夹'bin'、'include'、'lib'\n\n3. 将第一步中'bin'中的文件复制到第二步中'bin'文件夹下\n   将第一步中'include'中的文件复制到第二步中'include'文件夹下\n   将第一步中'lib'文件夹下'x64'文件夹中的文件复制到第二步中'lib'文件夹下'x64'文件夹中\n\n4. 接着添加path环境变量：`C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.0\\lib\\x64`\n\n至此，安装完成，在cmd中输入nvcc -V查看是否安装完成\n","categories":["tech"]},{"title":"SSM","url":"/2022/09/27/SSM/","content":"\n# SSM\n\n## Spring\n\n### 简介\n\nSpring是一个IOC(DI)和AOP容器框架。\n\n可以管理所有的组件（类）\n\n### IOC和AOP\n\n> IOC控制反转（容器）\n\n反转：将主动创建变为被动获取\n\n> DI依赖注入\n\n容器能知道某个类运行时需要另外哪个类，通过反射的形式，将容器中准备好的对象注入该类（利用反射给属性赋值）\n\n#### bean\n\n```xml\n<!-- 无参创建对象（默认）-->\n<!--        一个Bean标签可以注册一个组件（对象、类）\n  \t\t\tclass要写注册的组件的全类名，\n    \t\tid是该对象的唯一标识\n    \t\tname是别名，可以同时取多个,以逗号或分号分隔\n    -->\n<bean id=\"person\" class=\"com.demo.spring.person\" name=\"li;zhang;wang\">\n<!--        使用property为Person对象的属性赋值-->\n        <property name=\"lastName\" value=\"张三\"></property>\n        <property name=\"age\" value=\"23\"></property>\n        <property name=\"email\" value=\"bni@bni.com\"></property>\n        <property name=\"gender\" value=\"男\"></property>\n</bean>\n    \n<!-- 有参创建对象的三种方式-->\n1.下标赋值\n    <constructor-arg index=\"0\" value=\"张三\">\n2.类型\n    <constructor-arg type=\"java.lang.String\" value=\"张三\">\n3.参数名\n    <constructor-arg name=\"name\" value=\"张三\">\n```\n\n#### spring配置\n\n1.别名alias\n\n```xml\n<!--    如果添加了别名，也可以使用别名-->\n    <alias name=\"person\" alias=\"li\"></alias>\n```\n\n2.import\n\n一般团队开发，可以导入其他的xml配置文件\n\n```xml\n<import resource=\"beans2.xml\"/>\n```\n\n\n\n#### bean的作用域\n\n1.单例模式（singleton）\n\n全局只有一个对象\n\n2.原型模式（prototype）\n\n每次获取都是新的对象\n\n#### bean自动装配\n\n```java\n<!--    byName会自动装配和set方法后的值相同的id的对象-->\n<!--    byType会自动装配和set的类型相同的对象-->\n    <bean id=\"person\" class=\"com.demo.spring.Person\" autowire=\"byName\">\n        \n<!-- 使用注解自动装配，需要导入约束配置支持-->\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <context:annotation-config/>\n\n</beans>\n```\n\n#### 注解\n\n> @Component\n\n类上加@Component相当于<bean id=\"person\" class=\"com.demo.spring.person\">\n\n> 衍生注解\n\n- dao [@Repository]\n- service [@Service]\n- controller [@controller]\n\n#### 代理\n\n> 静态代理\n\n类似中介\n\n> 动态代理\n\n利用反射\n\n- 一个动态代理类代理的是一个接口，一般就是对应的一类业务\n- 一个动态代理类可以代理多个类，只要实现了同一个接口即可\n\n```java\npublic class ProxyInvocationHandler implements InvocationHandler {\n\n    private Object target;\n\n    public Object getProxy(){\n        return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(),this);\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\n        Object result = method.invoke(target, args);\n        return result;\n    }\n\n    public void setTarget(Object target) {\n        this.target = target;\n    }\n\n    public void log(String msg){\n        System.out.println(\"执行了\" + msg + \"方法\");\n    }\n}\n```\n\n#### Spring代理\n\n## MyBatis\n\n1.配置mybatis-config.xml文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <environments default=\"development\">\n        <environment id=\"development\">\n            <transactionManager type=\"JDBC\"/>\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/>\n                <property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8\"/>\n                <property name=\"username\" value=\"root\"/>\n                <property name=\"password\" value=\"1254503008\"/>\n            </dataSource>\n        </environment>\n    </environments>\n    <mappers>\n        <mapper resource=\"org/mybatis/example/BlogMapper.xml\"/>\n    </mappers>\n</configuration>\n```\n\n2.写配置类\n\n```java\n//工具类sqlSessionFactory --> sqlSession\npublic class MybatisUtils {\n\n    static {\n        String resource = \"mybatis-config.xml\";\n        InputStream inputStream = null;\n        try {\n            inputStream = Resources.getResourceAsStream(resource);\n            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n}\n```\n\n### 万能map\n\n假设实体类或库表中字段或参数过多，应当考虑使用map\n\n### mybatis配置\n\n- configuration（配置）\n  - [properties（属性）](https://mybatis.org/mybatis-3/zh/configuration.html#properties)\n  - [settings（设置）](https://mybatis.org/mybatis-3/zh/configuration.html#settings)\n  - [typeAliases（类型别名）](https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases)\n  - [typeHandlers（类型处理器）](https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers)\n  - [objectFactory（对象工厂）](https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory)\n  - [plugins（插件）](https://mybatis.org/mybatis-3/zh/configuration.html#plugins)\n  - environments（环境配置）\n    - environment（环境变量）\n      - transactionManager（事务管理器）\n      - dataSource（数据源）\n  - [databaseIdProvider（数据库厂商标识）](https://mybatis.org/mybatis-3/zh/configuration.html#databaseIdProvider)\n  - [mappers（映射器）](https://mybatis.org/mybatis-3/zh/configuration.html#mappers)\n\n> typeAliases\n\n可以给类起别名，也可以直接扫描一个包，其下所有类默认为小写名称、\n\n```xml\n<typeAliases>\n    <typeAlias type=\"com.demo.pojo.User\" alias=\"User\"/>\n    <package name=\"com.demo.pojo\"/>\n</typeAliases>\n```\n\n> 生命周期和作用域\n\n![image-20210807111225663](C:\\Users\\Jet\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210807111225663.png)\n\n### LOMBOK插件\n\n自动编写getter，setter等，无需手动赋值\n\n![image-20210809155458897](C:\\Users\\Jet\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210809155458897.png)\n\n# springMVC\n\nspingmvc框架以请求为驱动，围绕一个中心Servlet分派请求及提供其他功能。\n\n![image-20210828233325754](C:\\Users\\Jet\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210828233325754.png)\n\n使用DispatcherServlet来进行调度管理。\n\n\n\n![image-20210827165707752](C:\\Users\\Jet\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210827165707752.png)\n\n![image-20210827165750515](C:\\Users\\Jet\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210827165750515.png)\n\n![image-20210827165755615](C:\\Users\\Jet\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210827165755615.png)\n\n创建springmvc项目步骤\n\n1. 新建一个web项目\n2. 导入相关jar包\n3. 编写web.xml，注册DispatcherServlet\n4. 编写springmvc配置文件\n5. 接下来创建对应的控制类，controller\n6. 最后完善前端视图和controller之间的对应\n7. 测试运行调试\n\nspringmvc必须配置三大件：\n\n**处理器映射器，处理器适配器，视图解析器**\n\n只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/mvc\n       http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd\n       http://www.springframework.org/schema/context\n       http://www.springframework.org/schema/context/spring-context-4.2.xsd\">\n\n<!--    自动扫描包-->\n    <context:component-scan base-package=\"com.demo.controller\"/>\n<!--    自动过滤静态资源，去除.mp4等处理不了的资源-->\n    <mvc:default-servlet-handler />\n    <!--支持mvc注解驱动\n        在spring中一般采用@RequestMapping注解来完成映射关系\n        要想使用@RequestMapping注解生效\n        必须向上下文中注册DefaultAnnotationHandlerMapping\n        和一个AnnotationMethodHanlerAdapter实例\n        这两个实例分别在类级别和方法级别处理，\n        而annotation-driven配置帮助我们自动完成上述两个实例的注入-->\n    <mvc:annotation-driven/>\n\n    <!--视图解析器 : 模板引擎 Thymeleaf Freemarker等-->\n    <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n        <property name=\"prefix\" value=\"/WEB-INF/jsp/\"/>\n        <property name=\"suffix\" value=\".jsp\"/>\n    </bean>\n\n</beans>\n```\n\n# springboot\n\n## 注解\n\n```java\npackage cn.gacl.annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n/**\n * 这是一个自定义的注解(Annotation)类 在定义注解(Annotation)类时使用了另一个注解类Retention\n * 在注解类上使用另一个注解类，那么被使用的注解类就称为元注解\n * \n * @author \n * \n */\n@Target( { ElementType.METHOD, ElementType.TYPE })\n//Target注解决定MyAnnotation注解可以加在哪些成分上，如加在类身上，或者属性身上，或者方法身上等成分\n@Retention(RetentionPolicy.RUNTIME)\n//Retention注解决定MyAnnotation注解的生命周期\n/*\n * @Retention(RetentionPolicy.SOURCE)\n * 这个注解的意思是让MyAnnotation注解只在java源文件中存在，编译成.class文件后注解就不存在了\n * @Retention(RetentionPolicy.CLASS)\n * 这个注解的意思是让MyAnnotation注解在java源文件(.java文件)中存在，编译成.class文件后注解也还存在，\n * 被MyAnnotation注解类标识的类被类加载器加载到内存中后MyAnnotation注解就不存在了\n */\n/*\n * 这里是在注解类MyAnnotation上使用另一个注解类，这里的Retention称为元注解。\n * Retention注解括号中的\"RetentionPolicy.RUNTIME\"意思是让MyAnnotation这个注解的生命周期一直程序运行时都存在\n */\n@Documented \n//注解表明这个注解应该被 javadoc工具记录\n@Inherited\n//表名该注解所在的类若为父类则可以被子类继承该父类的注解\npublic @interface MyAnnotation {\n}\n```\n\n```java\n@Deprecated:若某类或某方法加上该注解之后，表示此方法或类不再建议使用，调用时也会出现删除线，但并不代表不能用，只是说，不推荐使用，因为还有更好的方法可以调用。\n```\n\n","categories":["tech"]},{"title":"Springboot集成Dubbo2.7.8","url":"/2022/09/27/Springboot 集成Dubbo2.7.8示例/","content":"\n# Springboot 集成Dubbo2.7.8示例\n\n## consumer&provider\n\n### 依赖\n\n新建springboot项目后，引入以下额外依赖，Dubbo的consumer和provider的依赖相同\n\n```xml\n<dependency>\n    <groupId>org.apache.dubbo</groupId>\n    <artifactId>dubbo-spring-boot-starter</artifactId>\n    <version>2.7.8</version>\n</dependency>\n\n<dependency>\n    <groupId>com.101tec</groupId>\n    <artifactId>zkclient</artifactId>\n    <version>0.10</version>\n</dependency>\n\n<dependency>\n    <groupId>org.apache.curator</groupId>\n    <artifactId>curator-recipes</artifactId>\n    <version>4.2.0</version>\n</dependency>\n```\n\n### provider\n\n建立子工程provider来作为生产者\n\n![image-20210913215341110](C:\\Users\\Jet\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210913215341110.png)\n\n其中application.properties:\n\n```properties\nserver.port=8081\n# 服务应用名字\ndubbo.application.name=provider-server\n# 注册中心地址\ndubbo.registry.protocol=zookeeper\ndubbo.registry.address=zookeeper://localhost:2181\n# 哪些服务要被注册\ndubbo.scan.base-packages=com.example.provider.service\n# 协议\n#dubbo.protocol.host=192.168.0.1\nspring.main.allow-bean-definition-overriding=true\ndubbo.protocol.name=dubbo\ndubbo.protocol.port=20880\n```\n\nTicketServiceImpl:\n\n版本号一定要填写！\n\n```java\npackage com.example.provider.service;\n\nimport org.apache.dubbo.config.annotation.DubboService;\n\n@DubboService(version = \"1.0\")\npublic class TicketServiceImpl implements TicketService{\n\n    @Override\n    public String getTicket(String name) {\n        return name;\n    }\n}\n```\n\nTicketService：\n\n```java\npackage com.example.provider.service;\n\npublic interface TicketService {\n\n    String getTicket(String name);\n}\n```\n\n### consumer\n\n引入provider的接口，注意接口包路径一定要一致\n\n目录：\n\n![image-20210913215745601](C:\\Users\\Jet\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210913215745601.png)\n\napplication.properties:\n\n```properties\nserver.port=8083\n\n# 消费者也要暴露自己的名字\ndubbo.application.name=consumer-server\n# 注册中心的地址\ndubbo.registry.protocol=zookeeper\ndubbo.registry.address=zookeeper://localhost:2181\ndubbo.scan.base-packages=com.example.consumer.service\n# 协议\nspring.main.allow-bean-definition-overriding=true\ndubbo.protocol.name=dubbo\ndubbo.protocol.port=20881\n```\n\nUserServiceImol:\n\n@DubboService注解会让这个服务变成provider，而@DubboReference则让服务变成consumer，同时加的时候该服务既是provider又是consumer，版本号都要加，否则会报错\n\n```java\npackage com.example.consumer.service;\n\nimport com.example.provider.service.TicketService;\nimport org.apache.dubbo.config.annotation.DubboReference;\nimport org.apache.dubbo.config.annotation.DubboService;\nimport org.springframework.stereotype.Component;\n\n//@DubboService(version = \"1.0\")\n@Component\npublic class UserServiceImpl implements UserServicei{\n    //想拿到provider-server提供的票，要去注册中心拿到服务\n    @DubboReference(version = \"1.0\") \n    TicketService ticketService;\n\n    @Override\n    public void buyTicket(){\n        String ticket = ticketService.getTicket(\"我\");\n        System.out.println(ticket);\n        System.out.println(\"shit\");\n    }\n}\n```\n\nUerServicei：\n\n```java\npackage com.example.consumer.service;\n\npublic interface UserServicei {\n    public void buyTicket();\n}\n```\n\n## 环境搭建\n\n### 注册中心zookeeper\n\n完成整个rpc框架调用还需要注册中心，这里使用zookeeper，并加上dubbo的监控中心来可视化监控服务\n\n下载apache-zookeeper-3.7.0-bin\n\n运行bin文件夹中的zkServer.cmd启动zookeeper\n\n### 监控中心dubbo-admin\n\n下载dubbo-admin\n\n为前后端分离项目\n\n启动其中的dubbo-admin-ui，这里使用vscode打开，在终端输入npm run dev\n\n启动其中的dubbo-admin-server，这里用idea打开，直接运行即可\n","categories":["tech"]},{"url":"/2022/09/27/java日志/","content":"# java日志\n\n日志框架技术：JUL、Logback、Log4j、Log4j2\n\n日志门面技术：JCL、SLF4j\n\n每一种日志框架都有自己单独的API，要使用对应的框架就要使用对应的API\n\n使用日志门面技术可以屏蔽日志框架技术的不同，可在项目中随意改动日志框架 \n\n## JUL\n\njava.util.logging \n\nJava原生日志框架\n\n## Log4j\n\nApache的一个开源项目\n\n## Logback\n\n由Log4j之父做的另一个开源项目\n\n业界乘坐log4j的后浪，一个可靠、通用且灵活的java日志框架\n\n## Log4j2\n\nLog4j官方的第二个版本，各方面与Logback相似\n\n具有插件式结构、配置文件优化等特征\n\nSpring Boot1.4版本后不再支持log4j\n\n## 日志门面技术\n\n可以屏蔽日志框架的不同，只要日志门面做的好，随意换另外一个日志框架，应用程序不需要修改任意一行代码就可以直接上线\n\n### SLF4J\n\n中间使用桥接器和日志框架桥接\n\n\n\n\n\n"},{"title":"Java","url":"/2022/09/27/Java/","content":"\n# IDEA\n\n| 快捷键               | 功能                                 |\n| -------------------- | ------------------------------------ |\n| `Alt+Enter`          | 导入包、自动修正代码、接口自动载入   |\n| `Ctrl+Y`             | 删除光标所在行                       |\n| `Ctrl+D`             | 复制光标所在行内容，插入光标位置下面 |\n| `Ctrl+Alt+L`         | 格式化代码                           |\n| `Ctrl+Shift+/`       | 选中代码注释，多行注释，再按取消注释 |\n| `Ctrl+n`             | 搜索包                               |\n| `Alt+Ins`            | 自动生成代码，toString,get,set等方法 |\n| `Alt+Shift+上下箭头` | 移动当前代码行                       |\n| `ctrl+f12`           | 在类中搜索方法或常量                 |\n| `alt + shift + e`    | 批量修改名称                         |\n| `alt+6`              | 查找TODO注释                         |\n\nidea中，默认当前路径是project的根目录\n\n| Java速写缩略语 | 代码                                     |\n| -------------- | ---------------------------------------- |\n| psvm           | public static void main(String[] args){} |\n| sout           | System.out()                             |\n| array.fori     | 数组正序遍历                             |\n| array.forr     | 数组倒序遍历                             |\n\n# Java\n\n## 数据类型四类八种\n\n| 整形       | **byte(1)、short(2)、int(4) 、long(8)** |\n| ---------- | --------------------------------------- |\n| **浮点型** | **float(4)、double(8)**                 |\n| **字符型** | **char(2)**                             |\n| **布尔型** | **boolean(1)**                          |\n\n整数可以表示为：123_221_333类似于书面中的逗号123,221,333\n\n| 基本类型 | 包装类    |\n| -------- | --------- |\n| byte     | Byte      |\n| short    | Short     |\n| int      | Integer   |\n| long     | Long      |\n| float    | Float     |\n| double   | Double    |\n| char     | Character |\n| boolean  | Boolean   |\n\n包装类都在java.lang包下\n\n\n\n## 编译器的两种优化\n\n- 变量的常量优化\n- 对于byte/short/char三种类型，若右侧数值未超范围，则自动补上(byte/short/char)，即强制转移\n\n## switch语句\n\n1. 多个case后面的数值不可以重复\n\n2. switch后面小括号中只能是下列数据类型\n\n   基本数据类型：byte/short/char/int\n\n   引用数据类型：String字符串、enum枚举\n\n## 重载\n\n1. 参数个数不同\n2. 参数类型不同\n3. 参数的多类型顺序不同\n\n## 数组\n\n格式：数据类型[] 数组名称 = new 数据类型[数组长度]{元素1、元素2...}\n\n```java\n//静态初始化\nint[] arrayA = new int[300]{element1、element2、...};\nint[] arrayB = {element1、element2、...};\n//动态初始化\nint[] arrayA = new int[300];\n```\n\n初始化数组有两种格式：标准格式/省略格式\n\n一维数组的输出：System.out.println(Arrays.toString(array))\n\n多维数组的输出：System.out.println(Arrays.deepToString(array))\n\n建立空数组时，数组内的数据会有默认值。\n\n- 整数类型，默认为0\n- 浮点类型，默认为0.0\n- 字符类型，默认为\"\\u0000\"\n- 引用类型，默认为null\n\n---\n\n> 一个数组的内存图\n\n![image-20200803212355839](C:\\Users\\Jet\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200803212355839.png)\n\n---\n\n数组一旦创建，长度不可再改变\n\n> 数组方法\n\n`array.length`：得到数组长度\n\n`array.fori`：快捷生成数组遍历\n\n> 数组调用\n\n```java\npublic static void printArray(int[] array){}\n```\n\n> 对象数组\n\n类名[] array = new 类名[length]\n\n### Arrays类工具\n\n`java.util.Arrays`是一个与数组相关的工具类，里面提供了大量静态方法，用来实现数组常见的操作。\n\n`public static string tostring(数组)`：将参数数组变成字符串（按照默认格式：[元素1，元素2，元素3...]）\n`public static void sort(数组)`：按照默认升序（从小到大）对数组的元素进行排序。\n\n1. 如果是数值，sort默认按照升序从小到大\n2. 如果是字符串，sort默认按照字母升序\n3. 如果是自定义的类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持。\n\n## 字符串\n\n- 字符串的内容并不能被改变\n- String str所创建的str中存放的是字符串的地址值\n\n```java\n//字符串和数字相加的类型转换\nString x = \"1.1\";\ndouble y = Double.parseDouble(x) + 2 \n//字符串的创建(3+1)\npublic static void main(String[]args){\n    //使用空参构造\n    String strl =new String()；//小括号留空，说明字符串什么内容都没有。\n    System.out.println(“第1个字符串：“+str1);\n    //根据字符数组创建字符串\n    char[] charArray={'A','B','C'};\n    String str2=new String（charArray）;\n    System.out.println(“第2个字符串：“+str2);\n    //根据字节数组创建字符串\n    byte[]byteArray={97，98，99};\n    String str3=new String（byteArray）;\n    System.out.println(“第3个字符串：“+str3);\n    //直接创建\n    String str4=\"Hello\";\n    system.out.printin(“第4个字符串：“+str4);\n}}\n```\n\n> 字符串的内存调用\n\n1. 对于引用类型来说，==进行的是地址值的比较\n2. 双引号直接写的字符串在常量池当中，new的不在池当中\n\n![image-20200809190009177](C:\\Users\\Jet\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200809190009177.png)\n\n\n\n> 方法\n\n`String.equals(str)`：对比两个字符串内容是否相等，推荐将常量写在前面\n\n`String.equalsIgnoreCase(str)`：忽略大小写进行比较\n\n`public int Length()`：获取字符串当中含有的字符个数，拿到字符串长度。\n\n`public String concat(String str)`：将当前字符串和参数字符串拼接成为返回值新的字符串。\n\n`public char charAt(int index)`：获取指定索引位置的单个字符。\n\n`public int indexof(String str)`：查找参数字符串在本字符串当中首次出现的索引位置，如果没有返回-1值。\n\n`public String substring(int index)`：截取从参数位置一直到字符串末尾，返回新字符串。\n\n`public String substring(int begin，int end)`：截取从begin开始，一直到end结束，中间的字符串。备注：[begin，end），包含左边，不包含右边。\n\n`public char[]tocharArray()`：将当前字符串拆分成为字符数组作为返回值。\n\n`public byte[]getBytes()`：获得当前字符串底层的字节数组。\n\n`public String replace(Charsequence oldString，Charsequence newstring)`：将所有出现的老字符串替换成为新的字符串，返回替换之后的结果新字符串。\n\n`public String[] split(String regex)`：按照参数的规则，将字符串切分成为若干部分。\n\n<u>注意事项</u>：split方法的参数其实是一个正则表达式”，今后学习。今天要注意：如果按照英文句点“.”进行切分，必须写\"\\\\\\\\.\"\n\n## 系统输入输出\n\n```java\n#系统输入\nScanner scanner = new Scanner(System.in);\nbyte age = scanner.nextByte();\n#系统输出\nSystem.out\n```\n\n## 类的定义\n\n一个标准的类通常要有下面四个组成部分\n\n1. 所有的成员变量都要使用private关键字修饰\n2. 为每一个成员变量编写一对Getter/Setter方法\n3. 编写一个无参数的构造方法\n\n```java\npublic class Student {\n    String name;\n    int age;\n    private boolean male;  //定义private关键字\n    \n    //---------------------------------//\n    //为private关键字定义getter/setter方法\n    //对于boolean类型，其getter方法要用isXxx()\n    public void setMale(boolean b) {\n        male = b;\n    }\n    public void isMale() {\n        return male;\n    }\n\t//---------------------------------//\n    public void SetName(String str) {\n        name = str;\n    }\n    public String getName() {\n        return name;\n    }\n    //---------------------------------//\n    public void eat(){}\n    public void sleep(){}\n}\n```\n\n### 抽象类\n\n```java\n//抽象类\npublic abstract class Animal{\n    //抽象方法\n    public abstract void eat();\n}\n```\n\n子类必须覆盖重写父类的抽象方法\n\n关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。\n\n1. 抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。\n\n> 理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。\n\n2. 抽象类中，可以有构造方法是供子类创建对象时，初始化父类成员使用的。\n\n> 理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。\n\n3. 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。\n\n> 理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。\n\n4. 抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。\n\n> 理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。\n\n### 内部类\n\n定义在一个类内部的类\n\n1. 成员内部类\n2. 局部内部类（包含匿名内部类）\n\n#### 成员内部类\n\n```java\n成员内部类的定义格式：\n修饰符 class 外部类名称{\n\t修饰符 cLass 内部类名称{\n//…\n}}\n…\n```\n\n注意：内用外，随意访问；外用内，需要内部类对象\n\n> 如何使用成员内部类？有两种方式：\n\n1. 间接方式：在外部类的方法当中，使用内部类；然后main只是调用外部类的方法。\n\n2. 直接方式，公式：\n   类名称 对象名 = new 类名称()；\n\n`【外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();】`\n\n> 如果出现了重名现象，格式为：外部类.this.外部类成员变量名\n\n```java\npublic class Outer{\n\tint num=10；//外部类的成员变量\n\tpublic class Inner{\n\t\tint num=2e；//内部类的成员变量\n\t\tpublic void methodInner(){\n\t\t\tint num=30；//内部类方法的局部变量\n                System.out.print1n（num）；//局部变量，就近原则\n                System.out.print1n（this.num）；//内部类的成员变量\n                System.out.print1n（Outer.this.num）；//外部类的成员变量\n        }}}             \n```\n\n#### 局部内部类\n\n如果一个类是定义在一个方法内部的，那么这就是一个局部内部类。\n“局部”：只有当前所属的方法才能使用它，出了这个方法外面就不能用了。\n\n定义格式：\n\n```java\n修饰符 class 外部类名称{\n    修饰符 返回值 类型 外部类方法名称(参数列表){\n        class局部内部类名称（\n\t\t\t//…\n}}}\n```\n\n> 类的权限修饰符：\n\npublic>protected>（default）>private定义一个类的时候，权限修饰符规则：\n\n1. 外部类：public/（default）\n\n2. 成员内部类：public/protected/（default）/private\n\n3. 局部内部类：什么都不能写\n\n> 局部内部类，如果希望访间所在方法的局部变量，那么这个局部变量必须是【有效final的】。即只赋值一次\n\n备注：从Java 8+开始，只要局部变量事实不变，那么final关键字可以省略。\n原因：\n\n1. new出来的对象在堆内存当中。\n\n2. 局部变量是跟着方法走的，在栈内存当中。\n\n3. 方法运行结束之后，立刻出栈，局部变量就会立刻消失。\n\n4. 但是new出来的对象会在堆当中持续存在，直到垃圾回收消失。所以需要不变的变量\n\n#### 匿名内部类\n\n如果接口的实现类（或者是父类的子类）只需要使用唯一的一次，那么这种情况下就可以省略掉该类的定义，而改为使用【匿名内部类】。\n\n匿名内部类的定义格式：\n`接口名称 对象名 = new 接口名称(){//覆盖重写所有抽象方法}`\n\n对格式`new接口名称(){...}`进行解析：\n1.new代表创建对象的动作\n\n2.接口名称就是匿名内部类需要实现哪个接口\n\n3.{.…}这才是匿名内部类的内容\n\n另外还要注意几点问题：\n\n1. 匿名内部类，在【创建对象】的时候，只能使用唯一一次。如果希望多次创建对象，而且类的内容一样的话，那么就必须使用单独定义的实现类了。\n\n2. 匿名对象，在【调用方法】的时候，只能调用唯一一次。如果希望同一个对象，调用次方法，那么必须给对象起个名字。\n\n3. 匿名内部类是省略了【实现类/子类名称】，但是匿名对象是省略了【对象名称】\n\n强调：匿名内部类和匿名对象不是一回事！！！\n\n#### 静态内部类\n\n\n\n## 面向对象\n\n> 一个对象的内存图\n\n![image-20200804210233751](C:\\Users\\Jet\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200804210233751.png)\n\n### 三大特征\n\n封装性、继承性、多态性\n\n#### 继承\n\nJava中只有单继承\n\n![image-20200813182824341](C:\\Users\\Jet\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200813182824341.png)\n\n`public class 子类 extends 父类`\n\n> 继承关系中，父子类构造方法的访间特点\n\n1. 子类构造方法当中有一个默认隐含的“super（）“调用，所以一定是先调用的父类构造，后执行的子类构造。\n\n2. 子类构造可以通过super关键字来调用父类重载构造。\n\n3. super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。\n\n- 总结：\n  子类必须调用父类构造方法，不写则赠送super（）；写了则用写的指定的super调用，super只能有一个，还必须是第一个。\n\n在父子类的继承关系当中，如果成员变量重名，则创建子类对象时，访间有两种方式：\n\n1. 直接通过子类对象访问成员变量：\n\n- 等号左边是谁，就优先用谁，没有则向上找\n\n2. 间接通过成员方法访问成员变量：\n\n- 该方法属于谁，就优先用谁，没有则向上找。\n\n> 子类方法中重名的三种变量的访问\n\n- 局部变量：直接访问\n- 子类变量：this.name\n- 父类变量：super.name\n\n> 继承中的覆盖\n\n方法覆盖重写的注意事项：\n1. 必须保证父子类之间方法的名称相同，参数列表也相同。\n   `@Override`：写在方法前面，用来检测是不是有效的正确覆盖重写。\n   这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。\n\n2. 子类方法的返回值必须【小于等于】父类方法的返回值范围。\n   小扩展提示：`java.Lang.object`类是所有类的公共最高父类（祖宗类），`java.Lang.string`就是object的子类。\n\n3. 子类方法的权限必须【大于等于】父类方法的权限修饰符。\n   小扩展提示：`public`>`protected`>(default)>`private`备注：（default）不是关键字`default`，而是什么都不写，留空。\n\n![image-20200813233711604](C:\\Users\\Jet\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200813233711604.png)\n\n#### 多态\n\n代码中体现多态性：父类引用指向子类对象\n\n格式：\n\n父类名称 对象名 = new 子类名称()；\n\n或：\n\n接口名称 对象名 = new 实现类名称();\n\n>多态中访问成员变量\n\n- 直接通过对象名称访问，看等号左边是谁，优先用谁，没有则向上找\n- 间接通过成员方法访问，看该方法属于谁，优先用谁，没有则向上找\n\n> 多态中访问成员方法\n\n看new得到是谁，就优先用谁，没有则向上找\n\n---\n\n口诀：（对于定义对象语句）\n\n- 成员变量：编译看左边，运行还看左边\n- 成员方法：编译看左边，运行看右边\n\n> 为什么用多态？\n\n![image-20200817201232145](C:\\Users\\Jet\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200817201232145.png)\n\n比较统一\n\n## 变量\n\n局部变量和成员变量\n\n1. **定义的位置不一样**\n   局部变量：在方法的内部\n   成员变量：在方法的外部，直接写在类当中\n\n2. **作用范围不一样**\n   局部变量：只有方法当中才可以使用，出了方法就不能再用成员变量：整个类全都可以通用。\n\n3. **默认值不一样**\n   局部变量：没有默认值，如果要想使用，必须手动进行赋值成员变量：如果没有赋值，会有默认值，规则和数组一样\n\n4. 内存的位置不一样（了解）\n\n   局部变量：位于栈内存；成员变量：位于堆内存\n\n5. 生命周期不一样（了解）\n\n   局部变量：随着方法进栈而诞生，随着方法出栈而消失\n\n   成员变量，随着对象创建而诞生，随着对象呗垃圾回收而消失\n\n## 方法\n\n三要素：方法名、参数列表、返回值\n\n### 构造方法\n\npublic 类名称(参数类型 参数名称) {\n\n​\t\t方法体\n\n}\n\n```jav\npublic class Student {\n\n\tpublic Student() {\n\t\n\t}\n}\n```\n\n## 匿名对象\n\n```java\nnew 类名();\n\npublic class Demoe2Anonymous{\n    public static void main（String[]args）{\n        //普通使用方式\n        Scanner sc=new Scanner（System.in）；\n        int num=sc.nextInt（）；\n        //匿名对象的方式\n        int num=new Scanner（System.in）.nextInt（）；\n        System.out.printtn（\"输入的是：\"+num）；\n        //使用一般写法传入参数\n        Scanner sc=new Scanner（System.in）；\n        methodParam（sc）；\n        //使用匿名对象来进行传参\n        methodParam（new Scanner（System.in））；\n\n        Scanner sc=methodReturn（）；\n        int num=sc.nextInt（）；\n        System.out.println（“输入的是：\"+num）；\n    }\n    public static void methodParam（Scanner sc）{\n    \tint num=sc.nextInt（）；\n        System.out.println（“输入的是：“+num）；\n    }\n    public static Scanner methodReturn（）{\n    \t//Scanner sc=new Scanner（System.in）；\n        return new Scanne(System.in);\n```\n\n## 集合\n\n### ArrayList集合、泛型\n\n其长度并没有限制\n\n<>中写的是泛型，泛型只能是引用类型（包装类），不能是基本类型\n\n```java\nArrayList<String> list = new ArrayList<>();\npublic static void main(String[] args){\n        System.out.println(\"Hello world\");\n        ArrayList<String> list =new ArrayList<String>();\n        //添加元素\n        boolean success = list.add(\"赵又廷\");\n        System.out.println(success);\n        list.add(\"迪丽热巴\");\n        System.out.println(list);\n        //删除某元素\n        String who = list.remove(1);\n        System.out.printf(\"将%s删除\",who);\n        System.out.println(\"\\n\"+list);\n        //获取某元素\n        String name = list.get(0);\n        System.out.println(name);\n    \t//获取集合长度\n    \tint size = list.size();\n    }\n```\n\n## 关键字\n\n### `static`\n\n- 内容不再属于对象，而属于类\n\n静态变量：类名称，静态变量\n静态方法：类名称.静态方法（）\n\n注意事项：\n\n1. 静态不能直接访问非静态。\n   原因：因为在内存当中是【先】有的静态内容，【后】有的非静态内容。\n   “先人不知道后人，但是后人知道先人。”\n\n2. 静态方法当中不能用this。\n   原因：this代表当前对象，通过谁调用的方法，谁就是当前对象。\n\n```java\npublic class Demoe2StaticMethod{\n\tpublic static void main（String[]args）{\n        MyClass obj=new MyClass()；//首先创建对象\n        //然后才能使用没有static关键字的内容\n        obj.method()；\n        //对干静态方法来说，可以通过对象名进行调用，也可以直接通过类名称来调用。\n        obj.methodstatic()；//正确，不推荐，这种写法在编译之后也会被javac翻译成为“类名称.静态方法名”\n        MyClass.methodStatic()；//正确，推荐\n        //对于本来当中的静态方法，可以省略类名称\n        myNethod()；\n        Demoe2StaticMethod.myMethod()；//完全等效\n        public static void myMethod(){\n        System.out.printin(\"自己的方法！\")；\n}}\n```\n\n> static内存图\n\n![image-20200813100228928](C:\\Users\\Jet\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200813100228928.png)\n\n> 静态代码块\n\n```java\n//静态代码块的内容\npublic class 类名称{\n    static{}\n}\n```\n\n特点：\n\n- 当第一次用到本类时，静态代码块执行唯一的一次。\n- 静态内容总是优先于非静态，所以静态代码块比构造方法先执行。\n\n### `super`\n\n`super`关键字的用法有三种：\n\n1. 在子类的成员方法中，访问父类的成员变量。\n\n2. 在子类的成员方法中，访问父类的成员方法。\n\n3. 在子类的构造方法中，访问父类的构造方法。`super()`\n\n### `this`\n\n`super`关键字用来访问父类内容，而`this`关键字用来访间本类内容。用法也有三种：\n\n1.在本类的成员方法中，访问本类的成员变量。\n\n2.在本类的成员方法中，访问本类的另一个成员方法。\n\n3.在本类的构造方法中，访问本类的另一个构造方法。`this()`\n\n在第三种用法当中要注意：\n\n- `this(…)`调用也必须是构造方法的第一个语句。\n- super和this两种构造调用，不能同时使用\n\n### `instanceof`\n\n`对象 instanceof 类名称`：会返回一个boolean值结果，也就是判断前面的对象能不能当作后面类型的实例。\n\n### `final`\n\n`final`关键字代表最终、不可改变的\n\n1. 修饰一个类\n\n   ```java\n   public final class 类名称{\n       //...\n   }\n   ```\n\n   此类不能有任何子类\n\n2. 修饰一个方法\n\n   ```java\n   public final void method(){\n   \t//...\n   }\n   ```\n\n   该方法不能被覆盖重写\n\n3. 修饰一个局部变量\n\n   ```java\n   final in num = 100;//仅能有唯一一次赋值\n   ```\n\n   该变量不能再进行更改\n\n   对基本类型来说，其值不可变\n\n   对引用类型来说，其地址不可变 \n\n4. 修饰一个成员变量\n\n   - 使用`final`之后必须手动赋值，不会再给默认值\n   - 可以进行直接赋值或通过构造方法赋值\n   - 必须保证类当中所有重载的构造方法，都最终会对`final`的成员变量进行赋值\n\n## 常用类\n\n### Math类\n\n`java.lang.Math`类是数学相关的工具类，里面提供了大量的静态方法，完成与数学运算相关的操作\n\n`public static double abs(double num)`：获取绝对值。有多种重载\n\n`public static double ceil(double num)`：向上取整\n\n`peblic static double floor(double num)`：向下取整\n\n`public static Long round(double num)`：四舍五入\n\n## 接口\n\n接口就是多个类的公共规范。\n接口是一种引用数据类型，最重要的内容就是其中的：抽象方法\n\n如何定义一个接口的格式：\npublic interface 接口名称（\n\t//接口内容\n}\n<u>备注</u>：换成了关键字interface之后，编译生成的字节码文件仍然是：java-->.class。\n\n> 如果是Java7，那么接口中可以包含的内容有：\n\n1. 常量\n\n2. 抽象方法\n\n> 如果是Java8，还可以额外包含有：\n\n3. 默认方法\n\n4. 静态方法\n\n> 如果是Java9，还可以额外包含有：\n\n5. 私有方法\n\n### 接口定义\n\n在任何版本的Java中，接口都能定义抽象方法。\n格式：\n\npublic abstract 返回值类型方法名称（参数列表）；注意事项：\n\n1. 接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract\n\n2. 这两个关键字修饰符，可以选择性地省略。（今天刚学，所以不推荐。）\n\n3. 方法的三要素，可以随意定义。\n\n```java\npublic interface MyInterfaceAbstract{\n    //这是一个抽象方法\n    public abstract void methodAbs1（）；\n    //这也是抽象方法\n    abstract void methodAbs2（）；\n    //这也是抽象方法\n    public void methodAbs3（）；\n    //这也是抽象方法\n    void methodAbs4（）；\n}\n```\n\n### 接口实现\n\n接口使用步骤：\n\n1. 接口不能直接使用，必须有一个实现类来实现该接口。\n\n格式：\n\n```java\npublic class 实现类名称 implements 接口名称{\n    //...\n}\n```\n\n\n\n2. 接口的实现类必须覆盖重写（实现）接口中所有的抽象方法。\n   实现：去掉abstract关键字，加上方法体大括号。\n3. 创建实现类的对象，进行使用。\n4. 若不想重写所有方法，则该实现类必须是抽象类\n\n### 接口的默认方法\n\n```java\npublic default void methodDefault(){\n    //\n}\n```\n\n使用默认方法，在接口升级时，可避免没有重写该方法的实现类报错\n\n### 接口的静态方法\n\n```java\npublic static void methodstatic(){\n    //\n}\n```\n\n<u>注意事项</u>：不能通过接口实现类的对象来调用接囗当中的静态方法。\n\n正确用法：通过接口名称，直接调用其中的静态方法。\n\n格式：接口名称.静态方法名（参数）；\n\n### 接口的常量定义\n\n接囗当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰。\n\n从效果上看，这其实就是接口的【常量】\n\n格式：\n`public static final 数据类型常量名称=数据值`；\n\n备注：\n一旦使用final关键字进行修饰，说明不可改变。\n\n注意事项：\n\n1. 接口当中的常量，可以省略public static final，注意：不写也照样是这样。\n2. 接口当中的常量，必须进行赋值；不能不赋值。\n3. 接口中常量使用完全大写的命名，并用下划线进行分割\n\n### 继承父类并实现接口\n\n```java\npublic class Zi extends Fu implements MyInterface {\n    \n}\n```\n\n使用接口的时候，需要注意：\n\n1. 接口是没有静态代码块或者构造方法的。\n\n2. 一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。\n\n格式：\n\n```java\npublic class MyInterfaceImpl implements MyInterfaceA，MyInterfaceB{\n//覆盖重写所有抽象方法\n}\n```\n\n\n\n3. 如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可\n\n4. 如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类\n\n5. 如果实现类所实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写\n\n6. 一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法\n\n\n\n### 对象的转型\n\n> 对象的向上转型\n\n对象的向上转型，其实就是多态写法：\n\n格式：`父类名称对象名=new子类名称()`；`Animal animal =new Cat()`；\n\n含义：右侧创建一个子类对象，把它当做父类来看待使用。创建了一只猫，当做动物看待，没问题。\n\n注意事项：向上转型一定是安全的。从小范围转向了大范围，从小范围的猫，向上转换成为更大范围的动物。\n\n类似于：`double num=100`;//正确，int-->double，自动类型转换。\n\n> 对象的向下转型\n\n2.对象的向下转型，其实是一个【还原】的动作。\n\n格式：子类名称对象名=（子类名称）父类对象；\n\n含义：将父类对象，【还原】成为本来的子类对象。\n\n`Animal animal=new Cat()`；//本来是猫，向上转型成为动物\n\n`Cat cat=(Cat)animal`；//本来是猫，已经被当做动物了，还原回来成为本来的猫\n\n注意事项：\na. 必须保证对象本来创建的时候，就是猫，才能向下转型成为猫。\n\nb. 如果对象创建的时候本来不是猫，现在非要向下转型成为猫，就会报错。\n\n类似于：`int num=(int)10.0`；//可以     int num=(int)10.5；//不可以，精度损失\n\n## 四种权限修饰符\n\n| 能否使用     | public  > | protected  > | (default  > | private |\n| ------------ | --------- | ------------ | ----------- | ------- |\n| 同一个类     | √         | √            | √           | √       |\n| 同一个包     | √         | √            | √           | ×       |\n| 不同包子类   | √         | √            | ×           | ×       |\n| 不同包非子类 | √         | ×            | ×           | ×       |\n\n### 更新和删除数据\n\n> 更新UPDATE\n\n```mysql\nUPDATE IGNORE customers\nSET cust_name  = 'The Fudds',\n\tcust_email = 'elmer@fudd.com'\nWHERE cust_id = 10005;\n/* IGNORE 关键字表示当发生错误时，整个UPDATE操作被取消*/\n```\n\n> 删除\n\n```mysql\n/*DELETE*/\nDELETE FROM custmers\nWHERE cust_id = 10006;\n/*TRUNCATE 清空某张表*/\nTRUNCATE TABLE \n```\n\n### 异常处理\n\n```java\n//打印异常树\ntry{\n    ...\n}catch(Exception e){\n    e.printStackTrace();\n}\n```\n\n","categories":["tech"]},{"title":"IIN项目软件环境安装指南","url":"/2022/09/27/IIN项目软件环境安装指南/","content":"\n## IIN项目软件环境安装指南\n\n### 前端\n\n> 软件配置\n\n未指定版本下载最新版即可\n\n| 功能          | 推荐软件 |\n| ------------- | -------- |\n| web调试浏览器 | 火狐     |\n| 前端代码调试  | VsCode   |\n| 包管理器      | Node.js  |\n\n以上软件需进入相应官方网站下载并进行安装，安装目录根据具体环境配置，在安装完成并配置相应系统环境变量后，还需进行如下配置。\n\n启动终端使用`npm`命令分别安装vue2.6.10、vue-router3.0.6，在安装完成之后输入`npm start`，若能正常启动项目，则前端环境搭建完成，否则根据提示进行其他插件的补充安装。\n\n### 后端\n\n> 软件配置\n\n| 功能         | 推荐软件      |\n| ------------ | ------------- |\n| Java工具包   | JDK1.8        |\n| 代码调试工具 | Intellij IDEA |\n| Java管理工具 | Maven         |\n\n在数据库配置用户名和密码后，在IDE中进入主程序/src/main/resources/文件夹下，打开application.yml文件进行数据库的连接配置。之后正常启动即可。\n\n### 数据库\n\n| 功能       | 推荐软件 |\n| ---------- | -------- |\n| 数据存储   | MySQL    |\n| 数据库管理 | Navicat  |\n\n### 算法学习\n\n建议python3.7.4","categories":["tech"]},{"title":"Hexo博客搭建指南","url":"/2022/09/27/hexo指南/","content":"\n# Hexo博客搭建指南\n\n## 安装Node.js\n\nNode.js下载地址：[Download | Node.js (nodejs.org)](https://nodejs.org/en/download/)\n\n下载后进行安装，安装后检测是否安装完成：\n\n`node -v`\n\nnode.js会同时安装npm，检测：\n\n`npm -v`\n\n## 安装Hexo\n\n使用npm命令安装Hexo：\n\n`npm install -g hexo-cli`\n\n## 初始化博客\n\n`hexo init blog`\n\n也可以直接从已有的github仓库拉取代码\n\n## 配置博客\n\n_config.yml文件，为主题配置文件\n\n如下为我的配置\n\n```yaml\n# Hexo Configuration\n## Docs: https://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site\ntitle: Jettisons' Blog\nsubtitle: 'Hello,world'\ndescription: 'Jettison'\nkeywords:\nauthor: Jettison\navatar: /0.jpg\nlanguage: en\ntimezone: 'Asia/Shanghai'\n\n# URL\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: http://yoursite.com\nroot: /\npermalink: :year/:month/:day/:title/\npermalink_defaults:\npretty_urls:\n  trailing_index: true # Set to false to remove trailing 'index.html' from permalinks\n  trailing_html: true # Set to false to remove trailing '.html' from permalinks\n\n# Directory\nsource_dir: source\npublic_dir: public\ntag_dir: tags\narchive_dir: archives\ncategory_dir: categories\ncode_dir: downloads/code\ni18n_dir: :lang\nskip_render:\n\n# Writing\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\ntitlecase: false # Transform title into titlecase\nexternal_link:\n  enable: true # Open external links in new tab\n  field: site # Apply to the whole site\n  exclude: ''\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: false\nrelative_link: false\nfuture: true\nhighlight:\n  enable: true\n  line_number: true\n  auto_detect: false\n  tab_replace: ''\n  wrap: true\n  hljs: false\nprismjs:\n  enable: false\n  preprocess: true\n  line_number: true\n  tab_replace: ''\n\n# Home page setting\n# path: Root path for your blogs index page. (default = '')\n# per_page: Posts displayed per page. (0 = disable pagination)\n# order_by: Posts order. (Order by date descending by default)\nindex_generator:\n  path: ''\n  per_page: 10\n  order_by: -date\n\n# Category & Tag\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n\n# Metadata elements\n## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta\nmeta_generator: true\n\n# Date / Time format\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n## updated_option supports 'mtime', 'date', 'empty'\nupdated_option: 'mtime'\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 10\npagination_dir: page\n\n# Include / Exclude file(s)\n## include:/exclude: options only apply to the 'source/' folder\ninclude:\nexclude:\nignore:\n\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: next\n\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: 'git'\n  repo: https://@github.com/Jettisons/Jettisons.github.io.git\n  branch: master\n\n```\n\n配置文件编写完成后\n\n安装Git部署插件\n\n`npm install hexo-deployer-git --save`\n\n## 网站上线\n\n`hexo clean`\n\n`hexo g -d`\n\n完成后便可以输入https://jettisons.github.io/登录自己的博客\n\n## 编写文章\n\n文章放在source目录下的_post文件夹中，为md格式的文件","categories":["tech"]},{"title":"Hello World","url":"/2022/09/27/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n\n### After changing your theme\n\n```bash\n$ hexo clean\n$ hexo g -d\n```"},{"title":"Git Notebooks","url":"/2022/09/27/GIT/","content":"\n# GIT\n\n## 创建版本库\n\n创建并提交一个README.md文件\n\n```markdown\nmkdir learn_git\ncd learn_git\ngit init\ntouch README.md\ngit add README.md\ngit commit -m \"first commit\"\ngit remote add origin git@gitee.com:jettison/learn_git.git\ngit push -u origin master //第一次推送加上 -u，之后不用\n```\n\n## 查看状态\n\n`git status`：可查看是否有没有提交的修改\n\n`git diff + 文件名`：查看文件做了什么修改\n\n`git diff + 版本号..版本号`：查看两个版本有什么区别\n\n`git diff HEAD -- 文件名`：查看工作区和版本库里面最新版本的区别\n\n`git log`：命令显示从最近到最远的提交日志\n\n`git log --pretty=oneline`：简洁版e\n\n`cat + 文件名`：查看文件内容\n\n`git reflog`：记录操作的每一次命令\n\n`git remote (-v)`：（详细）查看远程库的信息，若无权限则看不到push地址\n\n## 系统配置\n\n`git config --system -- list`：查看系统config\n\n`git config --global  --list`：查看当前用户（global）配置\n\n`git config --local  --list`：查看当前仓库配置信息\n\n## 版本替换\n\n`git reset --hard HEAD^`：回退到上一个版本\n\n`git reset --hard + 版本号`：还原这个版本\n\n`git checkout -- 文件名`：把文件在工作区的修改全部撤销，用版本库里版本替换工作区版本\n\n## 分支管理\n\n`git checkout -b 分支名称`：创建并切换到某一分支，该命令相当于\n\n`git branch dev`+`git checkout dev`\n\n`git branch`：查看当前分支\n\n`git branch -r`：查看远程分支\n\n`git branch -a`：查看所有分支\n\n`git branch -d dev`：删除dev分支\n\n鼓励使用switch切换分支\n\n`git branch -D dev`：强行删除没有merge的dev分支\n\n`git switch -c dev`：创建并切换到dev分支\n\n`git switch 分支`：切换某分支\n\n\n\n`git merge dev`：用于合并指定分支到当前分支\n\n`git merge --no-ff -m \"merge with no-ff\" dev`：不适用快速模式合并分支\n\n\n\n`git branch --set-upstream-to=origin/dev dev`：将本地分支与远程分支建立链接\n\n`git rebase`：可以把本地未push的分叉提交历史整理成直线；\n\n`git log --name-status` 每次修改的文件列表, 显示状态\n\n`git log --name-only` 每次修改的文件列表\n\n`git log --stat` 每次修改的文件列表, 及文件修改的统计\n\n`git whatchanged` 每次修改的文件列表\n\n`git whatchanged --stat` 每次修改的文件列表, 及文件修改的统计\n\n`git show` 显示最后一次的文件改变的具体内容\n\n`git show -5` 显示最后 5 次的文件改变的具体内容\n\n`git show commitid` 显示某个 commitid 改变的具体内容\n\n## 修复bug，现场保护与还原\n\n`git stash`：可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作\n\n`git stash list`：查看保存的工作现场\n\n`git stash apply (列名)`：恢复现场，不删除stash内容\n\n`git stash drop`：删除stash内容\n\n`git stash pop`：恢复现场并删除stash内容\n\n`git cherry-pick 提交号`：将某一提交复制到当前分支\n\n## 删除文件\n\n`rm 文件名`：删除文件\n\n`git rm 文件名`：删除版本库中该文件，之后还要`git commit`\n\n`git remote rm 库名`：删除远程库链接\n\n\n\n## 两分支修改冲突\n\n在A分支上修改后提交，在B分支上又修改后提交，两个分支merge的时候会发生冲突，此时会提示修改，修改完再提交即可\n\n`git log --graph --pretty=oneline --abbrev-commit`：使用该命令可看分支历史\n\n## 推送和抓取分支\n\n> push\n\n`git push <远程主机名> <本地分支名>:<远程分支名>`：完整push命令\n\n`git push origin 分支名`：推送本地分支到存在追踪关系的远程分支，若不存在，将创建\n\n> pull\n\n`git pull <远程主机名> <远程分支名>:<本地分支名>`：pull命令完整格式\n\n`git pull origin next`：远程分支与当前分支合并\n\n`git pull origin`：若当前分支与远程分支存在追踪关系，可省略远程分支名\n\n`git pull`：如果当前分支只有一个追踪分支，远程主机名都可以省略\n\n如果远程主机删除了某个分支，默认情况下，`git pull` 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致`git pull`不知不觉删除了本地分支。\n\n但是，你可以改变这个行为，加上参数 `-p` 就会在本地删除远程已经删除的分支。\n\n```ba\n$ git pull -p\n# 等同于下面的命令\n$ git fetch --prune origin \n$ git fetch -p\n```\n\n## 多人协作流程\n\n当修改完文件后\n\n首先`git add`\n\n`git add .` ：他会监控工作区的状态树，使用它会把工作时的**所有变化提交**到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。\n\n`git add -u `：他仅监控**已经被add的文件**（即tracked file），他会将被修改的文件提交到暂存区。add -u 不会提交新文件（untracked file）。（git add --update的缩写）\n\n`git add -A `：是上面两个功能的合集（git add --all的缩写）\n\n---\n\n然后`git commit -m '提交说明'`\n\n多人协作的工作模式通常是这样：\n\n1. 首先，可以试图用`git push origin <branch-name>`推送自己的修改；\n2. 如果推送失败，则因为远程分支比你的本地更新，需要先用`git pull`试图合并；\n3. 如果合并有冲突，则解决冲突，并在本地提交；\n4. 没有冲突或者解决掉冲突后，再用`git push origin <branch-name>`推送就能成功！\n\n如果`git pull`提示`no tracking information`，则说明本地分支和远程分支的链接关系没有创建，用命令`git branch --set-upstream-to=origin/<branch> release` 。\n\n这就是多人协作的工作模式，一旦熟悉了，就非常简单\n\n\n\n`git remote add 起个名 远程库链接`：连接远程库\n\n## 标签\n\n`git tag`：查看所有标签\n\n`git tag v1.0`：给当前版本打上标签v1.0\n\n`git tag v0.9 + <commit id>`：给某一个版本打上标签\n\n`git show + <tag name>`：查看标签信息\n\n`git tag -a v0.1 -m \"version 0.1 released\" 1094adb`：创建带有说明的标签\n\n`git push origin <tag name>`：推送某标签到服务器\n\n`git push origin --tags`：推送全部标签到服务器\n\n`git tag -d <tag name>`：删除标签\n\n`git push origin :refs/tags/<tag name>`：从远程删除标签\n\n## Git放弃修改，强制覆盖本地代码\n\n1.`git fetch --all` //从远程拉取最新的代码 不merge\n\n2.`git reset --hard origin/develop` //使用指定分支的代码（此处develop）强制覆盖代码\n\n3.`git pull` //从远程拉取最新的代码 自动merge\n\n## Git远程分支不显示问题\n\n可执行`git config -l `命令，查看`git fetch` 的配置，上述问题可能是没有进行`git fetch`的配置（或者只配置了上游分支），可执行付下命令进行配置：\n\n`git config remote.origin.fetch +refs/heads/*:refs/remotes/origin/*`\n\n执行上述命令后，再进行git fetch 拉取分支，此时已包含所有远程分支。\n\n\n\n","categories":["tech"]}]